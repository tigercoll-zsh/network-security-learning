# Day009：安全协议与加密 - 证书与信任链

- 日期：2026-01-02
- 周次：第 2 周

## 学习目标

学完今天你应该能做到：

- 说清 **证书（X.509）在证明什么**：证明“某个公钥属于某个域名/组织”，并由谁背书
- 说清 **CA/中间证书/根证书** 的角色，以及“链验证”为什么能建立信任
- 能用 **Windows 自带工具**（无需 OpenSSL）拿到一个站点证书，并提取关键字段：SAN、Issuer、Validity、Key Usage
- （可选）会用 **OpenSSL** 做同样的检查，并理解 `verify`/`s_client` 的输出含义
- 能列出 3 类常见失败原因：**域名不匹配 / 链不完整或不被信任 / 证书过期或被撤销（策略相关）**

## 学习内容

### 1️⃣ 证书到底是什么（X.509 的一句话定义）

证书可以理解为：

- **一张“公钥身份证”**：把 _主体身份（域名/组织）_ 和 _公钥_ 绑定起来
- 由 **签发者（Issuer，通常是 CA）** 用自己的私钥签名背书

你真正验证的不是“证书长得像不像”，而是：

1. 证书上的域名是不是我访问的域名（SAN 优先）
2. 证书是否在有效期内
3. 颁发者是否可信（能不能一路追溯到受信任的根 CA）

### 2️⃣ CN、SAN、Key Usage：最常用的字段（面试/实战高频）

- **Subject**：证书主体，谁的证书
- **CN（Common Name）**：早期用来放域名，但现在 **不再推荐只靠 CN 匹配**
- **SAN（Subject Alternative Name）**：现代浏览器匹配域名的主要依据（可包含多个域名/通配符）
- **Issuer**：谁签发的（中间 CA / 根 CA）
- **Validity**：Not Before / Not After（时间不准会导致校验失败）
- **Key Usage / Extended Key Usage**：这把公钥允许干什么（如 Server Authentication）

补充（够用就行，不需要背 RFC）：

- **Serial Number（序列号）**：CA 给这张证书的“身份证号”，撤销/审计会用到
- **Signature Algorithm（签名算法）**：这张证书是如何被上级签名的（例如 `sha256RSA`）
- **Public Key（公钥）**：真正用于握手密钥协商/验证签名的那把公钥
- **Basic Constraints**：是否允许充当 CA（叶子证书一般 `CA:FALSE`）

域名匹配“怎么比对”（最常用规则）：

- **优先看 SAN**：SAN 里只要有一个名字能匹配访问域名即可
- **通配符**：`*.example.com` 只匹配一级子域（如 `a.example.com`），不匹配 `a.b.example.com`
- **IP 访问**：如果你用 IP 访问（例如 `https://1.2.3.4`），证书必须在 SAN 里有对应 IP 才算匹配

### 3️⃣ 证书链（Chain）/信任链（Trust Chain）怎么工作

基本结构（从服务器发给客户端的常见顺序）：

- 站点证书（Leaf / End-Entity）
- 1~N 个中间证书（Intermediate CA）
- （根证书 Root CA **通常不会**由服务器发给你，客户端系统里本来就有）

链验证的核心逻辑：

- 用“上一级证书”的公钥，验证“下一级证书”的签名是否正确
- 一直验证到“我本机信任的根 CA”则信任成立

把“链验证”拆成 3 句更容易理解的话：

1. **服务器把它的证书（leaf）给你**，并通常附带 1~N 张中间证书

2. **你用中间证书的公钥去验证 leaf 的签名**；再用更上一级验证中间证书……

3. 直到能拼出一条路，走到你系统里“已经信任”的根证书（Root CA），这条链才算闭合。

> 为什么根证书通常不由服务器发？因为“根证书是否可信”是由你的系统/浏览器预置的信任库决定的，服务器自己说“我信我自己”没意义。

### 3.1️⃣ Windows 信任库（你只要知道这几点）

在 Windows 上，证书“信不信”主要看系统证书存储（证书管理器）：

- **受信任的根证书颁发机构（Trusted Root Certification Authorities）**：根 CA 在这里 → 默认信任
- **中间证书颁发机构（Intermediate Certification Authorities）**：中间 CA 在这里，可帮助链构建
- **个人（Personal）**：你自己的证书/私钥（比如客户端证书）

打开方式（两种都行）：

- 运行：`certmgr.msc`（当前用户）
- 运行：`mmc` → 添加管理单元（Certificates）→ 选择“计算机帐户”（更接近系统层）

### 4️⃣ 撤销：CRL / OCSP（你需要记住的结论）

- **CRL**：证书撤销列表（列表可能大、更新慢）
- **OCSP**：在线查询某张证书是否被撤销（受网络/策略影响）
- 实际是否“强制检查撤销”，取决于浏览器/系统/组织策略，所以现实里常见的失败点仍是：域名/有效期/链不完整。

你可以把撤销当成“加分项”，先把下面 3 个最常见的失败点练熟：

1. 域名不匹配（SAN）
2. 证书过期/时间不准（Validity）
3. 链构建失败（缺中间/不受信任根）

### 5️⃣ 看到浏览器/命令行报错时，怎么快速定位原因

把问题按层拆开（建议照这个顺序排查）：

1. **连得上吗**：DNS/TCP 443 是否通（连不上就别谈证书）
2. **证书是不是这家网站的**：SAN 是否匹配你访问的域名
3. **证书还活着吗**：NotBefore/NotAfter 是否有效，系统时间是否正确
4. **链闭合了吗**：有没有中间证书、根是否受信任（企业内网常见）
5. **策略类**：是否强制 OCSP/CRL、是否需要客户端证书（mTLS）

常见现象 → 可能原因（够用版）：

- “证书不受信任/Unknown CA”：缺根 CA 或企业 CA 未导入
- “证书链不完整/Unable to get local issuer certificate”：服务器没发全中间证书（或客户端缺中间）
- “域名不匹配/Name mismatch”：SAN 不包含该域名（或你用 IP 访问）
- “证书过期/NotAfter”：证书过期或系统时间不准

## 实践任务（合法授权范围内）

> 目标：用“无需 OpenSSL”也能完成证书关键字段核验；有 OpenSSL 更好。

### 任务 1（无需 OpenSSL）：用 curl 抓取握手与证书信息

1. 选一个 HTTPS 站点（示例：`https://www.bing.com/`）
2. 执行（只请求头，带详细信息）：

说明：在 Windows PowerShell 里，`curl.exe` 的进度条/部分输出可能会被显示为 `NativeCommandError`，看起来像“报错”，但通常并不影响你拿到 TLS/HTTP 头信息。

更稳定的写法（不显示进度条，只看关键信息）：

```powershell
curl.exe -I --silent --show-error --location https://www.bing.com/
```

如果你还想看更详细的协商信息，再用：

```powershell
curl.exe -Iv --silent --show-error https://www.bing.com/
```

你要记录到“学习成果”里的信息（不同 Windows 版本输出略不同，能看到多少写多少）：

- TLS 版本/协商摘要（如有）
- 证书相关提示（如有）
- 重定向位置（如有）

### 任务 2（无需 OpenSSL）：用 PowerShell 获取站点证书并导出到文件

下面脚本会连接站点、取出服务器证书并导出为 `.cer`（DER），然后用系统工具查看：

```powershell
$hostName = "www.bing.com"
$tcp = New-Object System.Net.Sockets.TcpClient($hostName, 443)
$ssl = New-Object System.Net.Security.SslStream($tcp.GetStream(), $false, ({$true}))
$ssl.AuthenticateAsClient($hostName)
$cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($ssl.RemoteCertificate)
$path = "day009_$($hostName.Replace('.','_')).cer"
[System.IO.File]::WriteAllBytes($path, $cert.Export([System.Security.Cryptography.X509Certificates.X509ContentType]::Cert))
$cert | Format-List Subject, Issuer, NotBefore, NotAfter, Thumbprint
Write-Host "Exported to $path"
$ssl.Dispose(); $tcp.Close()
```

接着查看证书详细信息（系统自带）：

```powershell
certutil -dump .\day009_www_bing_com.cer
```

你重点找这些字段并摘录：

- Subject / Issuer
- Validity（NotBefore/NotAfter）
- SAN（Subject Alternative Name）
- EKU（如 Server Authentication）

### 任务 3（可选，有 OpenSSL 时）：查看链与验证结果

1. 直接看握手与证书链：

- `openssl s_client -connect www.bing.com:443 -servername www.bing.com -showcerts`

2. 验证链（需要你把中间证书/根证书准备成文件时才更完整）：

- `openssl verify -CAfile <root_or_bundle.pem> <leaf.pem>`

你要理解的输出关键词：

- `Verify return code: 0 (ok)`：链验证通过
- 其他非 0：要么链不完整、要么不受信任、要么用途/名称/时间有问题

### 任务 4（与 Wireshark 联动）：从抓包里对应到“证书链”

在 Wireshark 里过滤：

- `tls.handshake.type == 11`（Certificate）

找到 `Certificate` 消息后：

- 看证书列表里有几张（leaf + intermediates）
- 记录 leaf 的 Subject / Issuer / Validity
- 对照你在 PowerShell/certutil 中看到的字段是否一致

## 巩固练习（题与复盘）

### 题目 1：为何不再使用“仅 CN”做域名匹配？

要点：

- 现代证书允许一个证书覆盖多个域名/通配符，**SAN 才是标准位置**
- 浏览器实现与标准（RFC/CA/B Baseline Requirements）逐步要求以 SAN 为准
- 只看 CN 容易产生兼容性与安全边界问题

一句话回答模板：

- **现在以 SAN 为准**，CN 主要是历史兼容字段，不能再作为唯一匹配依据。

解题思路（你可以照着套）：

1. 先说“现代证书的规范位置在哪” → SAN
2. 再说“CN 的定位是什么” → 历史兼容
3. 最后给结论 → 只看 CN 不可靠/不符合现代验证逻辑

### 题目 2：链验证失败的 3 个典型原因是什么？

- 缺中间证书（服务器没发全）
- 客户端缺根 CA/企业 CA（不受信任）
- 时间不准或证书过期（NotBefore/NotAfter）

解题思路：把“链验证”拆成 3 次检查，然后每一步给一个会失败的点：

1. leaf 是否归属这个域名（SAN）
2. leaf 是否在有效期内（Validity）
3. leaf 的签名能不能一路验证到受信任根（链/信任库）

标准答案（直接写在笔记里也行）：

1. **缺中间证书**（服务器未发送完整链，导致无法构建到根）
2. **根不受信任**（客户端缺根 CA/企业 CA 未导入信任库）
3. **时间/有效期问题**（证书过期或系统时间不正确）

### 练习：给定证书，指出有效期与用途

从 `certutil -dump` 或证书查看器里找到：

- NotBefore / NotAfter
- Enhanced Key Usage（Server Authentication / Client Authentication 等）

解题思路：你只要在输出里“定位两个区域”就够了：

1. 找到 `NotBefore` 与 `NotAfter` 两行（有效期）
2. 找到 `Enhanced Key Usage`（用途）

参考答案模板（把括号里的内容替换成你看到的）：

- 有效期：从 **(NotBefore 时间)** 到 **(NotAfter 时间)**
- 用途（EKU）：包含 **(Server Authentication/Client Authentication/… )**，说明这张证书用于 **(服务器认证/客户端认证/… )**

## 评估标准（达成判定）

- 能说清“证书证明的是什么”，以及 CA/中间/根的关系
- 能从证书中定位并解释：SAN、Issuer、Validity、EKU/Key Usage（至少 4 项）
- 能用 Windows 工具导出并 `certutil -dump` 查看证书
- 能给出链验证失败的分层排查思路（链不完整 / 不受信任 / 时间与域名）

## 学习成果达成情况（由学习者填写）

### 截图与证据

- `certutil -dump` 关键字段截图或复制粘贴：
  - Subject：
  - Issuer：
  - Validity（NotBefore/NotAfter）：
  - SAN：
  - EKU：

### 关键命令与输出

- 命令：
  - `curl.exe -Iv https://...`
  - PowerShell 导出证书脚本（是否成功导出 `.cer`）：
  - `certutil -dump .\xxx.cer`
- 输出关键行摘录：
  - 证书指纹（Thumbprint）：
  - SAN 关键行：
  - Validity：

### 结论与反思

- 今天你确认到的 1 个事实证据（来自输出，不是“感觉”）：
- 你遇到的 1 个坑（例如：时间不准/站点重定向/输出差异）：
- 明天（Day010）你最想带着去验证的一个问题：

（示例填写，给自己一个可参考的“完整答案”）

- 今天你确认到的 1 个事实证据：
  - 我用 PowerShell 导出 `www.bing.com` 的证书后，看到 `Subject=CN=www.bing.com`，`Issuer=Microsoft Azure RSA TLS Issuing CA 04`，有效期 `NotBefore=2025-12-17` 到 `NotAfter=2026-06-15`（这些字段来自命令输出）。
- 我遇到的 1 个坑：
  - 在 Windows PowerShell 里直接跑 `curl.exe -Iv` 时，进度条/部分输出会显示成 `NativeCommandError`，看起来像失败；改用 `curl.exe -I --silent --show-error --location` 后信息更干净。
- 明天最想验证的问题：
  - 在 Wireshark 的 `Certificate` 握手里看到的证书列表（leaf + intermediates），是否能和我导出的证书字段一一对应？如果链不完整会在抓包里表现成什么？

---

## 参考答案（含思路，集中作答）

> 说明：下面把本文出现的所有“题目/练习”集中给出**思路 + 标准答案**；你做完再回来对照即可。

### 题目 1：为何不再使用“仅 CN”做域名匹配？

**思路**：

1. 先讲“现在标准在哪里” → SAN
2. 再讲“CN 的定位” → 历史兼容字段
3. 最后落到结论 → 只看 CN 可能匹配错误/不符合现代验证规则

**标准答案**：

- 现代 TLS/浏览器在做主机名验证时，**以证书的 SAN（Subject Alternative Name）为准**；CN（Common Name）主要用于历史兼容，不能再作为唯一依据。
- 原因是 SAN 才是标准字段，能表达多个域名/通配符等场景；只看 CN 会带来兼容性问题，也可能导致验证边界不清。

**常见误区**：

- 误区："CN 写了域名就一定能用" → 实际上很多实现会忽略 CN 或只在没有 SAN 时才回退。

### 题目 2：链验证失败的 3 个典型原因是什么？

**思路**：把链验证拆成“能否构建到根”的过程，分别给出会失败的点：

- 是否能拿到完整链（中间证书）
- 根是否受信任（信任库）
- 时间是否有效（有效期/系统时间）

**标准答案**：

1. **缺中间证书**：服务器没有把中间证书发全，客户端无法构建到受信任根
2. **根不受信任**：客户端没有对应根 CA（或企业 CA），导致 Unknown CA/Untrusted
3. **时间/有效期问题**：证书过期、未生效，或客户端系统时间不正确

### 练习：给定证书，指出有效期与用途

**思路**：只要会在输出里找两块信息即可：

- `NotBefore`/`NotAfter` → 有效期
- `Enhanced Key Usage (EKU)` → 用途

**标准答案模板（直接替换括号内容）**：

- 有效期：从 **(NotBefore 时间)** 到 **(NotAfter 时间)**
- 用途（EKU）：包含 **(Server Authentication/Client Authentication/… )**

**举例（示例答案，便于你对照格式）**：

- 有效期：从 **2025-12-17 06:38** 到 **2026-06-15 06:38**
- 用途（EKU）：包含 **Server Authentication**，说明这张证书用于 **服务器身份认证（HTTPS 网站）**

### 复盘题（衔接 Day010）：你明天最想带着去验证的一个问题是什么？

**思路**：选一个“能用抓包验证”的问题（能在 Wireshark 里看到证据），而不是抽象问题。

**示例答案**：

- 我想验证：当我访问 `https://www.bing.com/` 时，Wireshark 的 `Certificate` 握手消息里是否包含中间证书？如果只看到 leaf，没有 intermediate，那么客户端是如何补全链的（AIA 下载/系统缓存）？
