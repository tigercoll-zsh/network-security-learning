# Day013：安全协议与加密 - 加密应用与场景（傻瓜版能照做）

- 日期：2026-01-06
- 周次：第2周

## 学习目标

学完今天你应该能做到：

- 能把“加密”分成 3 类场景：**传输中**、**存储中**、**认证/签名**
- 能识别 5 个常见错误：
	- 明文存密码
	- 可逆加密存密码
	- 没盐（salt）
	- 迭代太低/用快哈希（如 SHA-256）直接存密码
	- 密钥硬编码/长期不轮换
- 能输出一张你自己的“应用加密检查清单”（照着抄也行）

## 学习内容

### 1️⃣ 传输中加密（In Transit）：你最常见看到的 TLS/HTTPS

你关注 3 点就够：

- **是否加密**：是不是 https（TLS）
- **是否验证身份**：证书是不是可信、域名是否匹配
- **是否能被降级/误用**：错误重定向、混合内容、老 TLS 版本

### 2️⃣ 存储中加密（At Rest）：盘上/库里的一切

这里容易犯的错是：

- “我把密码 AES 加密后存起来就安全了” → **不对**（因为密钥泄露/拿到库就能解）

正确方向：

- **密码存储**：用 KDF（专门为密码设计的慢哈希）
	- 推荐：Argon2 / scrypt / bcrypt / PBKDF2
	- 每个用户一个 salt
	- 合理迭代/成本参数
- **敏感数据（非密码）**：比如身份证号、银行卡
	- 可以做对称加密（AES-GCM/ChaCha20-Poly1305）+ 密钥管理

### 3️⃣ 认证/签名：你在 API、登录、证书里都能遇到

- API 签名：HMAC（Day012 已做过）
- Token 签名：JWT 可能用 HMAC 或 RSA/ECDSA（关键是验签）
- 证书：CA 用签名证明公钥归属

### 4️⃣ 密钥管理（KMS/轮换）：真正“拉开差距”的地方

工程上最常见翻车点：

- 密钥写在代码里（硬编码）
- 密钥和数据库放在同一台机器/同一套备份里
- 密钥永不轮换
- 没有最小权限控制（谁都能读）

你先从“能做到的最小实践”开始：

- 密钥放环境变量/配置中心（至少不进 git）
- 轮换：定义“多久换一次” + “出事怎么换”
- 权限：最小可用原则

## 实践任务（合法授权范围内）

> 今天做一个“密码存储安全评估”的小演练：你可以评估你自己的 demo、或者网上随便找段示例代码（只做阅读分析）。

### 任务 1（必做）：用“检查清单”评估一个密码存储方案

下面给你一个典型的坏例子（**不要照做**）：

```text
password_hash = sha256(password)
store(password_hash)
```

你需要写出为什么它不行：

- SHA-256 太快，容易被暴力破解（GPU/彩虹表）
- 没 salt，重复密码会有相同 hash

然后写出一个“够用版正确方案”（伪代码即可）：

```text
salt = random()
hash = KDF(password, salt, cost)
store(salt, hash, cost)
```

### 任务 2（可选，但强烈推荐）：用 Python 演示“快哈希 vs 慢 KDF”的区别

用标准库的 PBKDF2（这是 KDF 的一种）：

```powershell
python - << 'PY'
import os
import time
import hashlib

password = b"P@ssw0rd!"
salt = os.urandom(16)

start = time.time()
sha = hashlib.sha256(password).hexdigest()
print("sha256:", sha, "time=", (time.time()-start)*1000, "ms")

start = time.time()
pbk = hashlib.pbkdf2_hmac('sha256', password, salt, 200_000).hex()
print("pbkdf2:", pbk[:32] + "...", "time=", (time.time()-start)*1000, "ms")
PY
```

你要记录结论：

- PBKDF2 明显更慢（这是它的目的：让爆破成本变高）
- 有 salt，每次结果不一样（因为 salt 不一样）

### 任务 3（必做）：写一张“应用加密检查清单”（存档到今天的成果里）

把下面的清单复制到你的成果区，然后勾选：

- [ ] 传输：所有敏感接口必须 HTTPS
- [ ] 传输：证书有效、域名匹配、禁止忽略证书错误
- [ ] 密码：使用 KDF（bcrypt/scrypt/Argon2/PBKDF2），每用户 salt
- [ ] 密码：不要可逆加密存密码
- [ ] 数据：敏感字段加密（AES-GCM 等），密钥不进 git
- [ ] 密钥：轮换策略与应急替换流程
- [ ] 日志：不打印敏感信息（密码/Token/密钥）

## 巩固练习（题与复盘）

### 题 1：为什么不能用明文或可逆加密存储密码？

**思路**：你要把“数据库泄露”当成必然会发生的事故来设计。

- 明文：库泄露 = 全部密码直接曝光
- 可逆加密：只要密钥泄露或被拿到，密码仍然会被解出来
- 正确做法：用 KDF 哈希 + salt，让攻击者只能去猜（而且很慢）

### 题 2：设计一套密码存储策略（写到能落地）

**思路**：写 6 个要素：

1) 算法（KDF） 2) salt 3) 成本参数 4) 存哪些字段 5) 验证流程 6) 迁移/升级策略

## 评估标准（达成判定）

- 你写出至少 5 条“密码存储/密钥管理”风险点 + 对应改法
- 你能跑出 PBKDF2 示例并截图（可选任务 2 完成则更好）
- 你完成并保存“应用加密检查清单”

## 学习成果达成情况（由学习者填写）

### 截图与证据

- [ ] （可选）PBKDF2 演示输出截图

### 关键命令与输出

- PBKDF2 演示输出（粘贴关键行）：

### 结论与反思

- 我以前以为“加密存密码”可以；现在知道正确做法是 KDF + salt。
- 我需要继续补：密钥轮换与权限（KMS/配置中心）的工程实践。

## 集中参考答案（含思路）

### 题 1 参考答案

- 明文存密码：数据库一旦泄露，所有用户密码直接泄露。
- 可逆加密存密码：密钥一旦泄露/被误配置/被备份暴露，攻击者可以批量解密得到明文密码。
- 正确方式：用 KDF（如 bcrypt/scrypt/Argon2/PBKDF2）+ 每用户 salt + 合理成本参数，让攻击者即使拿到数据库也只能进行高成本猜测。

### 题 2 参考答案（可照抄）

1. 注册：生成随机 `salt`，使用 PBKDF2/Argon2 等 KDF 计算 `hash`，存储 `salt + hash + 参数(cost)`。
2. 登录：取出 `salt` 与参数，对用户输入密码再次计算 KDF，比较 hash 是否一致。
3. 参数升级：当 cost 提升时，用户下次登录成功后用新参数重新计算并覆盖存储。
4. 安全要求：限制登录尝试、启用 MFA、日志不记录密码与 hash。
5. 密钥管理：如需加密敏感字段，密钥放配置中心/KMS，不进代码仓库。

## 学习成果示例填写（可照抄）

### 截图与证据（示例）

- `images/day013_pbkdf2.png`：PBKDF2 比 sha256 慢很多的输出截图

### 关键命令与输出（示例）

- sha256 time：`0.1 ms`（示例）
- pbkdf2 time：`120 ms`（示例，机器不同会不一样）

### 结论与反思（示例）

- 设计密码存储时要假设数据库会泄露；目标是让攻击者“拿到库也很难爆破”。
- KDF 的“慢”不是缺点，是用来抗爆破的特性。
- 后续要把“密钥管理/轮换/最小权限”补进我的服务设计习惯。
