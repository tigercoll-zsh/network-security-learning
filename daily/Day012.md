# Day012：安全协议与加密 - 加密基础：哈希/对称/非对称（傻瓜版能照做）

- 日期：2026-01-05
- 周次：第2周

## 学习目标

学完今天你应该能做到：

- 一句话说清：**哈希**、**对称加密**、**非对称加密**分别解决什么问题
- 画出（或者口述）一个最小闭环：
	- “我怎么把消息加密发给你？”
	- “我怎么证明这条消息真的是我发的？”（签名/验签）
- 在 Windows 上用 **Python（标准库）** 做到：
	- 计算 SHA-256 哈希
	- 用 HMAC 生成“带密钥的哈希”（模拟 API 签名）
	- 生成 RSA 密钥对，并对文本做签名与验签

> 今天你不需要背算法细节；你要拿走的是：**能用、能解释、能避坑**。

## 学习内容

### 1️⃣ 三兄弟：哈希/对称/非对称，到底差在哪

你就记 3 句话：

- **哈希（Hash）**：
	- 输入任意内容，输出固定长度“指纹”。
	- **不可逆**（不能从指纹还原原文）。
	- 用来做：完整性校验、密码存储、文件校验。
- **对称加密（Symmetric）**：
	- **同一把密钥**加密/解密。
	- **快**，适合大数据量（比如 TLS 里真正传输数据的阶段）。
	- 难点：**密钥怎么安全分发**。
- **非对称加密（Asymmetric）**：
	- 一对钥匙：**公钥（public）**+**私钥（private）**。
	- 用来做：密钥交换、身份认证、签名。
	- 缺点：相对慢，不适合直接加密大文件。

把它们放到网络安全场景里：

- TLS/HTTPS：用非对称“谈判并安全交换对称密钥” → 然后主要靠对称加密传输
- 证书体系：用签名证明“这个公钥属于这个域名/组织”
- 密码存储：不要“加密存密码”，而是“哈希+盐+迭代”（Day013 会继续）

### 2️⃣ 签名与验签：你要会讲的最小流程

**签名（Signature）**的目标不是保密，是“证明真伪 + 防篡改”。

最小流程（背这个就够）：

1. 我有一段消息 $M$。
2. 我先算哈希 $H = hash(M)$（因为直接签大文本太慢）。
3. 我用**私钥**对 $H$ 签名得到 $S$。
4. 我把 $M + S$ 发给你。
5. 你收到后：
	 - 再算一遍 $H' = hash(M)$
	 - 用**我的公钥**验证签名 $S$ 是否能对应 $H'$
6. 能对应：说明消息没被改过，也确实来自拥有私钥的人。

> 一句话：**私钥签名，公钥验签；签的是“哈希指纹”，不是为了加密正文。**

### 3️⃣ HMAC：最常见的“接口签名”模型

HMAC = “带密钥的哈希”，非常常见。

- 你和服务器共享一个 secret
- 你把请求参数按规则拼成字符串
- 用 HMAC 算出一个签名
- 服务器用同样方法再算一遍，对比

它的价值：

- 能防止请求被篡改
- 能一定程度防止伪造（前提是 secret 不泄露）

## 实践任务（合法授权范围内）

> 今天全程本地做，不需要攻击任何东西；这些都是基础能力。

### 任务 1（必做）：用 Python 计算 SHA-256 哈希（完整性指纹）

在项目根目录新建一个临时文件（例如 `hash-demo.txt`），内容随便写一句话。

用 Python 计算 SHA-256：

```powershell
python - << 'PY'
import hashlib

data = b"hello day012"
print("data:", data)
print("sha256:", hashlib.sha256(data).hexdigest())
PY
```

你要记录 2 个现象：

- 内容只改 1 个字母，sha256 会完全变（雪崩效应）
- 同样内容算出来永远一样（确定性）

### 任务 2（必做）：用 HMAC 生成“带密钥的哈希”（模拟 API 签名）

```powershell
python - << 'PY'
import hmac
import hashlib

secret = b"my-secret"
msg = b"user=alice&amount=100"

sig = hmac.new(secret, msg, hashlib.sha256).hexdigest()
print("msg:", msg)
print("hmac_sha256:", sig)
PY
```

你要做一次对比实验：

- 把 `amount=100` 改成 `amount=1000`，签名会变
- 把 `secret` 改了，签名也会变

### 任务 3（必做）：生成 RSA 密钥对 + 签名/验签（本地演示）

Python 标准库没有直接的 RSA 签名 API，所以这里我们用 Windows 自带的 `certutil` 做一个“概念演示版”（不追求工程最佳实践，追求你能看到签名/验签闭环）。

> 如果你更想要“纯 Python 可跑”，我可以在后续某天加一段使用 `cryptography` 库的版本；但那需要额外安装依赖。

**演示方式（推荐）**：把今天重点放在 “哈希/HMAC” 两个必做任务，RSA 签名/验签先理解流程即可。

（可选）你也可以在后续安装 OpenSSL 或用 WSL 来做更标准的 RSA/ECDSA 签名演示。

## 巩固练习（题与复盘）

### 题 1：哈希与加密的区别是什么？

**思路**：抓住 3 个点：

- 能不能解回去（可逆 vs 不可逆）
- 主要目的（保密 vs 指纹/完整性）
- 有没有密钥（哈希一般无；加密一定有密钥）

### 题 2：简述一次签名流程（不要写错钥匙）

**思路**：写清“私钥签名、公钥验签”，以及“签的是哈希”。

## 评估标准（达成判定）

- 你能口述并举例：哈希/对称/非对称分别用在什么地方
- 你能跑通并截图保存：
	- SHA-256 输出
	- HMAC 输出 + 修改参数后签名变化
- 你能写出签名/验签最小流程（就 6 步那套）

## 学习成果达成情况（由学习者填写）

### 截图与证据

- [ ] 任务 1：sha256 输出截图
- [ ] 任务 2：hmac 输出截图（至少两次：改参数前/后）

### 关键命令与输出（粘贴关键片段）

- SHA-256：
	- 输入：
	- 输出：
- HMAC：
	- msg：
	- sig：

### 结论与反思

- 我今天搞清楚了：
- 我差点搞混的是：
- 明天我要继续补的是：

## 集中参考答案（含思路）

### 题 1 参考答案

- 哈希：不可逆，输出固定长度指纹，用于完整性校验/密码存储等。
- 加密：可逆，目的是保密，必须有密钥。
- 对称加密：同一把密钥加/解密，快，用于大量数据。
- 非对称加密：公私钥配对，用于密钥交换、身份认证、签名。

### 题 2 参考答案

1. 发送方对消息 $M$ 计算哈希 $H=hash(M)$。
2. 发送方用私钥对 $H$ 进行签名得到签名 $S$。
3. 发送方发送 $M$ 和 $S$。
4. 接收方对收到的 $M$ 再算哈希 $H'=hash(M)$。
5. 接收方用发送方的公钥验证 $S$ 是否对应 $H'$。
6. 验证通过：消息未被篡改且来自持有私钥的人。

## 学习成果示例填写（可照抄）

> 你可以先把“示例”改成你自己的时间与截图文件名。

### 截图与证据（示例）

- 任务 1：`images/day012_sha256.png`（PowerShell 输出 sha256）
- 任务 2：`images/day012_hmac_before.png`、`images/day012_hmac_after.png`（改参数后签名变化）

### 关键命令与输出（示例）

- SHA-256：`sha256: 0d3c...`（略）
- HMAC：
	- msg：`user=alice&amount=100`
	- sig：`c5a0...`（略）

### 结论与反思（示例）

- 哈希用于“指纹/完整性”，不是加密；加密用于“保密”。
- HMAC 很像“接口签名”：只要参数或 secret 变，签名就变。
- 我以前把“签名=加密”混在一起了；现在知道签名的重点是“证明真伪+防篡改”。
