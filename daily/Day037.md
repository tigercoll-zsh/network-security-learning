---
title: Day037：XSS 极限对抗 - 过滤绕过与 CSP 突破
tags:
  - 网络
  - 安全
  - 学习计划
categories:
  - 网络安全
abbrlink: 1f8b3
date: 2026-02-28
updated: 2026-02-28
---

# Day037：XSS 极限对抗 - 过滤绕过与 CSP 突破

- **日期**：2026-02-28
- **周次**：第 6 周
- **模块**：Web 漏洞进阶
- **主题**：XSS 高级绕过与 CSP 突破
- **预计学习时间**：3 小时

---

## 🎯 学习目标

学完今天你应该能做到：

- **标签对抗**：掌握在 `<script>`、`<img>`、`<a>` 等常用标签被禁用的情况下，寻找冷门标签（如 `<details>`、`<svg>`）实现弹窗。
- **编码艺术**：熟练运用 HTML 实体编码、JS 编码（十六进制、Unicode、八进制）以及各种混合编码绕过正则拦截。
- **突破 CSP**：理解 CSP (Content Security Policy) 的防御机制，并掌握 3 种以上的 CSP 绕过技巧。

<!--more-->

---

## 📚 完整学习内容（必读）

### 一、XSS 过滤器的“心理博弈”

大多数过滤器是基于关键词黑名单的。我们的策略是：**“寻找被遗忘的标签和属性”**。

#### 1.1 冷门标签与事件
- **常规被禁**：`<script>`, `onerror`, `onload`, `onclick`。
- **奇招**：
  - `<details open ontoggle=alert(1)>`：不需要用户交互，标签打开即触发。
  - `<svg onload=alert(1)>`：在图像渲染时触发。
  - `<video><source onerror=alert(1)>`。
  - `<math><maction xlink:href="javascript:alert(1)">Click Me</maction></math>`。

#### 1.2 属性分隔符的妙用
如果过滤器只检查 `alert(1)`，我们可以尝试在属性中使用特殊字符：
- `<img src=x onerror="&#97;lert(1)">` (HTML 实体编码)。
- `<img src=x onerror="eval('\x61\x6c\x65\x72\x74\x28\x31\x29')">` (Hex 编码)。
- 使用 `/` 代替空格：`<img/src="x"/onerror=alert(1)>`。

---

### 二、现代防御：CSP (内容安全策略) 深度解析

CSP 是浏览器端的一道硬防，通过 HTTP 头（`Content-Security-Policy`）告诉浏览器哪些外部资源是可以加载的。

#### 2.1 常见的 CSP 配置
- `script-src 'self'`：只允许加载本站脚本。
- `script-src 'unsafe-inline'`：允许内联脚本（极度危险，XSS 的福音）。

#### 2.2 绕过 CSP 的核心技巧
1.  **利用白名单站点重定向**：
    -   如果 CSP 允许 `google.com` 的脚本，而 Google 存在一个开放重定向或 JSONP 接口，攻击者可以借此加载恶意代码。
2.  **JSONP 回调攻击**：
    -   寻找白名单域名下的 JSONP 接口。
    -   Payload：`<script src="https://trust.com/api?callback=alert(1)//"></script>`。
3.  **利用不安全的指令**：
    -   如果配置了 `unsafe-eval`，可以使用 `setTimeout('恶意代码', 0)`。
4.  **数据传输协议绕过 (Data URI)**：
    -   有些老旧配置允许 `data:` 协议。

---

### 三、技术细节：DOM-based XSS 的进阶挖掘

DOM 型 XSS 不经过服务器，直接在浏览器端由于脚本处理不当导致。

#### 3.1 危险的“汇聚点” (Sinks)
- `innerHTML`：会将字符串解析为 HTML 标签。
- `document.write()`。
- `eval()`、`setTimeout()`、`setInterval()`。

#### 3.2 挖掘逻辑
1. 寻找 `location.hash`、`location.search`、`window.name` 等输入源。
2. 追踪这些变量是否在没有经过转义的情况下进入了上述“汇聚点”。

---

## 🗺️ 知识图谱

```
XSS 高级进阶
├── 过滤绕过策略
│   ├── 标签替换 (SVG, Details, Math)
│   ├── 编码混淆 (HTML, Unicode, Base64)
│   └── 语法变形 (反引号, 数组, 隐式调用)
└── 防御对抗 (CSP)
    ├── JSONP 劫持
    ├── 静态资源重定向
    └── Dangling Markup (挂起标记攻击)
```

---

## 🔧 实践任务

### 任务 1：绕过“最强”正则过滤 (40 分钟)
**情景**：后端过滤器如下：
`preg_replace('/<(script|img|a|on\w+)/i', '', $input);`
**要求**：
1. 写出 2 种不含上述关键词的 Payload。
2. 尝试利用 `<svg>` 标签实现弹窗。

### 任务 2：CSP 绕过实验 (50 分钟)
**环境**：本地搭建一个开启了 `script-src 'self' *.google.com;` 的页面。
**要求**：
1. 尝试直接插入 `<script>alert(1)</script>`，观察浏览器拦截信息。
2. 搜索并利用 Google 现有的 JSONP 接口（如 Google 搜索建议）尝试实现弹窗。

---

## 📝 巩固练习

### 练习 1：判断题
**题目**：只要在后端对 `<` 和 `>` 进行了转义（如变为 `&lt;`），就绝对能防止 XSS。对吗？
**参考答案**：**错误**。如果输入点是在属性值内（如 `<input value="...">`），攻击者不需要 `<>` 也能实现 XSS。比如输入 `" onfocus="alert(1)" autofocus "`。

### 练习 2：简答题
**题目**：什么是“反射型 XSS 的自我传播（XSS Worm）”？
**参考答案**：攻击者编写一段恶意 JS 代码，当用户点击链接触发 XSS 后，该脚本会自动模拟用户操作（如发朋友圈、发私信），并将带有 XSS Payload 的链接发送给好友，实现像病毒一样的自动传播。

---

## ✅ 评估标准

- [ ] 我能熟练使用 3 种以上的非常规标签（非 script/img）触发 XSS。
- [ ] 我理解 CSP 的基本原理并能看懂复杂的 CSP 策略配置。
- [ ] 我掌握了通过 JSONP 接口绕过 CSP 的实操技巧。

---

## 💡 知识卡片速查

### XSS 绕过三板斧
1.  **探测**：输入 `"'<script>alert(1)</script>` 看看哪些被吞了。
2.  **编码**：如果关键词被拦，尝试 Unicode（`\u0061`）或 HTML 实体（`&#x61;`）。
3.  **位移**：如果 `<` 被转义，尝试利用属性引号闭合。

---

> 💬 **老师寄语**：
> 不要迷信所谓的“完美过滤”。前端代码的灵活性决定了 XSS 永远有进化的空间。

```bash
git add daily/Day037.md
git commit -m "Day037: 完成 XSS 进阶绕过与 CSP 对抗"
```
