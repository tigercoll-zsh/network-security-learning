---
title: Day017：操作系统与脚本 - Shell/PowerShell 脚本入门与批处理
tags:
  - 网络
  - 安全
  - 学习计划
categories:
  - 网络安全
abbrlink: 44b1dfb5
date: 2026-01-10 00:00:00
updated: 2026-01-10 00:00:00

---
# Day017：操作系统与脚本 - Shell/PowerShell 脚本入门与批处理

- 日期：2026-01-10
- 周次：第 3 周

## 学习目标

学完今天你应该能做到：

- 理解 PowerShell 的**对象管道**机制及其在安全分析中的优势
- 掌握 PowerShell 的变量、循环、条件判断与函数编写
- **编写自动化脚本分析 Windows 安全日志（如统计爆破攻击源 IP）**
- **利用 PowerShell 进行简单的基线检查和信息收集**
- 能独立完成日志批量处理、数据清洗与 CSV 导出

---

<!--more-->

## 🗺️ 知识图谱

### 今日内容在整体知识体系中的位置

```
网络安全学习路径
├── 第 3 周：系统安全 (Linux/Windows)
│   ├── Day015：Linux 用户与权限管理
│   ├── Day016：Windows 安全基础
│   └── Day017：PowerShell 脚本与自动化安全
│       ├── 核心概念：Cmdlet、Pipeline、Object
│       ├── 实践技能：日志分析脚本、批量管理
│       └── 关联知识点：事件响应、威胁狩猎
    ├── Day018：Python 脚本基础
```

### 今日关键词

`PowerShell` · `Pipeline` · `Object` · `Log Analysis` · **`Automation`** · **`Threat Hunting`**

---

## 一、PowerShell 基础语法与对象管道

### 1.1 什么是 PowerShell？

- Windows 自带的命令行自动化工具，支持“对象管道”，比传统 cmd 强大很多
- 语法类似 C#/Python，支持变量、函数、条件、循环、模块
- 适合做批量运维、日志分析、自动化脚本

### 1.2 管道与重定向的区别

| 概念 | 作用 | 示例 | 结果 |
|------|------|------|------|
| 管道 `|` | 把前一命令的“对象”传给后一命令 | `Get-Process | Where-Object {$_.CPU -gt 10}` | 只保留 CPU>10 的进程 |
| 重定向 `>` | 把输出写到文件 | `Get-Process > procs.txt` | 文件里是纯文本 |
| 追加 `>>` | 追加到文件末尾 | `echo hello >> log.txt` | 文件内容不会被覆盖 |

### 1.3 PowerShell 与 Bash 最大差异

- PowerShell 管道传递的是“对象”，不是纯文本
- 可以直接用 `Select-Object`、`Where-Object`、`Group-Object` 等命令处理结构化数据

### 1.4 变量、类型与基本运算

```powershell
# 变量定义
$name = "Alice"
$age = 20

# 字符串拼接
Write-Output "姓名：$name，年龄：$age"

# 数组
$nums = 1,2,3,4,5

# 哈希表
$dict = @{user="bob"; role="admin"}
Write-Output $dict["user"]
```

### 1.5 条件判断与循环

```powershell
# if-else
if ($age -ge 18) {
    Write-Output "成年人"
} else {
    Write-Output "未成年人"
}

# for 循环
for ($i=0; $i -lt 5; $i++) {
    Write-Output $i
}

# foreach
foreach ($n in $nums) {
    Write-Output $n
}
```

### 1.6 函数与模块

```powershell
function Add-Two {
    param($a, $b)
    return $a + $b
}

$result = Add-Two 3 5
Write-Output $result
```

---

## 二、日志解析与批量处理实战（安全场景）

### 2.1 模拟生成“暴力破解”日志

为了演示，我们先生成一份模拟的 Windows 安全日志数据（CSV 格式）。

```powershell
# 生成 1000 条模拟日志
1..1000 | ForEach-Object {
    $eventID = (4624, 4625, 4625, 4625, 4625) | Get-Random # 故意让 4625 (失败) 多一些
    $ip = "192.168.1.$((Get-Random -Minimum 1 -Maximum 255))"
    $user = ("admin", "root", "guest", "test") | Get-Random
    $time = (Get-Date).AddMinutes(-$_).ToString("yyyy-MM-dd HH:mm:ss")

    [PSCustomObject]@{
        Time = $time
        EventID = $eventID
        User = $user
        SourceIP = $ip
    }
} | Export-Csv -Path .\security_logs.csv -NoTypeInformation
```

### 2.2 统计“攻击源 IP” Top 5

找出哪个 IP 尝试登录失败的次数最多（疑似暴力破解源）。

```powershell
# 读取 CSV 日志
$logs = Import-Csv .\security_logs.csv

# 筛选 EventID 4625 (登录失败)
$failed_logs = $logs | Where-Object { $_.EventID -eq 4625 }

# 统计 SourceIP 出现次数
$top_attackers = $failed_logs |
    Group-Object SourceIP |
    Sort-Object Count -Descending |
    Select-Object -First 5 Name, Count

# 显示结果
Write-Output "=== 疑似爆破源 IP Top 5 ==="
$top_attackers | Format-Table -AutoSize
```

### 2.3 统计“被攻击账号” Top 5

找出黑客最喜欢尝试爆破哪些用户名。

```powershell
# 继续使用上面的 $failed_logs
$top_targets = $failed_logs |
    Group-Object User |
    Sort-Object Count -Descending |
    Select-Object -First 5 Name, Count

Write-Output "=== 被攻击账号 Top 5 ==="
$top_targets | Format-Table -AutoSize
```

### 2.4 自动封禁 IP（模拟）

编写一个简单的逻辑：如果某个 IP 失败次数超过 50 次，就输出“封禁该 IP”。

```powershell
$threshold = 50
$failed_logs | Group-Object SourceIP | Where-Object { $_.Count -gt $threshold } | ForEach-Object {
    $bad_ip = $_.Name
    $count = $_.Count
    Write-Warning "发现恶意 IP: $bad_ip (失败次数: $count) -> 执行封禁逻辑..."
    # 实际场景中这里可以调用防火墙命令：New-NetFirewallRule ...
}
```

---

## 三、进阶：错误处理、正则、批量文件处理

### 3.1 错误处理（try/catch/finally）

```powershell
try {
    # 可能出错的代码
    $content = Get-Content .\not_exist.log -ErrorAction Stop
} catch {
    Write-Output "文件不存在！"
} finally {
    Write-Output "脚本执行完毕"
}
```

### 3.2 正则表达式提取日志字段

```powershell
# 假设日志格式：2026-01-01 12:00:00, alice, login
$line = "2026-01-01 12:00:00, alice, login"
if ($line -match "(?<time>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}), (?<user>\w+), (?<action>\w+)") {
    $matches["time"]  # 2026-01-01 12:00:00
    $matches["user"]  # alice
    $matches["action"] # login
}
```

### 3.3 批量处理多个日志文件

```powershell
# 假设有 log1.txt, log2.txt ...
Get-ChildItem . -Filter "log*.txt" | ForEach-Object {
    $file = $_.FullName
    $lines = Get-Content $file
    # ...对每个文件做统计
}
```

---

## 四、实战任务：编写自动化威胁猎杀脚本

> ⚠️ **任务背景**：你需要编写一个 PowerShell 脚本 `ThreatHunter.ps1`，用于在遭受攻击后快速收集关键信息。

### 任务 1：收集系统基本信息

**目标**：获取主机名、OS 版本、当前用户、IP 地址。

```powershell
function Get-SystemInfo {
    [PSCustomObject]@{
        Hostname = $env:COMPUTERNAME
        OS = (Get-CimInstance Win32_OperatingSystem).Caption
        CurrentUser = $env:USERNAME
        IPAddress = (Get-NetIPAddress | Where-Object AddressFamily -eq IPv4).IPAddress -join "; "
    }
}
```

### 任务 2：收集可疑的自启动项

**目标**：获取注册表 Run 键值，查找持久化后门。

```powershell
function Get-AutoRuns {
    Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Run |
    Select-Object * -ExcludeProperty PSPath, PSParentPath, PSChildName, PSDrive, PSProvider
}
```

### 任务 3：收集高危开放端口

**目标**：查找所有监听状态的端口及其对应进程。

```powershell
function Get-OpenPorts {
    Get-NetTCPConnection -State Listen |
    Select-Object LocalPort, OwningProcess, @{N="ProcessName";E={(Get-Process -Id $_.OwningProcess).ProcessName}}
}
```

### 任务 4：整合脚本并导出报告

**目标**：将上述功能整合，并生成 `Report.txt`。

```powershell
# ThreatHunter.ps1

Write-Output "正在收集系统信息..."
$sysInfo = Get-SystemInfo
$sysInfo | Format-List | Out-File "Report.txt"

Write-Output "正在检查自启动项..."
Get-AutoRuns | Format-List | Out-File "Report.txt" -Append

Write-Output "正在检查开放端口..."
Get-OpenPorts | Format-Table | Out-File "Report.txt" -Append

Write-Output "完成！报告已保存至 Report.txt"
```

### 任务 5（进阶）：检查文件哈希

**目标**：计算关键系统文件（如 `C:\Windows\System32\cmd.exe`）的 SHA256，用于对比是否被篡改。

```powershell
Get-FileHash C:\Windows\System32\cmd.exe | Format-List
```

---

## 五、巩固练习与评估标准

### 巩固练习

1.  **恶意脚本识别**：如果你看到一段 PowerShell 代码使用了 `IEX (New-Object Net.WebClient).DownloadString(...)`，这通常意味着什么？
2.  **混淆检测**：黑客经常使用 base64 编码来隐藏 PowerShell 命令（例如 `powershell -enc ...`）。写一个命令来解码一段 base64 字符串。
3.  **日志分析**：如何使用 PowerShell 快速筛选出 Windows 安全日志中 EventID 为 4624（登录成功）且 LogonType 为 10（远程桌面）的记录？
4.  **基线检查**：写一个单行脚本，检查“Windows 更新”服务（`wuauserv`）是否处于“运行”状态。
5.  **错误处理**：修改你的脚本，使其在无法读取注册表或访问被占用的文件时，不会报错退出，而是记录一条错误日志。

### 评估标准

- ✅ **自动化思维**：能用脚本替代重复的手工检查
- ✅ **数据处理**：能熟练使用 `Where-Object` 筛选恶意行为，用 `Group-Object` 统计攻击源
- ✅ **信息收集**：能编写函数获取系统关键信息（IP、进程、自启动）
- ✅ **安全意识**：能识别 PowerShell 中的高危函数（如 `IEX`）和混淆特征
- ✅ **代码质量**：脚本包含基本的错误处理和清晰的输出

---

## 六、参考资料与进阶阅读

- [PowerShell 蓝队防御指南](https://www.gitbook.com/book/adsecurity/powershell-blue-team-cheat-sheet)
- [PowerShell 恶意代码混淆与检测](https://www.fireeye.com/blog/threat-research/2018/07/malicious-powershell-detection-via-machine-learning.html)
- [微软官方 PowerShell 文档](https://docs.microsoft.com/zh-cn/powershell/)
- [PowerShell Gallery 脚本库](https://www.powershellgallery.com/)
- [PowerShell 正则表达式教程](https://docs.microsoft.com/zh-cn/powershell/scripting/learn/deep-dives/everything-about-regular-expressions)
- [PowerShell 管道与对象详解](https://docs.microsoft.com/zh-cn/powershell/scripting/learn/deep-dives/everything-about-pipelines)

---

## 七、学习成果达成情况（由学习者填写）

- [ ] demo.log 生成截图
- [ ] 统计结果输出截图
- [ ] fail.csv 导出截图
- [ ] 自己写的函数代码
- [ ] 错误处理脚本截图

---

**恭喜！你已掌握 PowerShell 脚本的核心技能。明天我们将学习 Python 脚本，进一步提升自动化与数据处理能力！** 🎉
