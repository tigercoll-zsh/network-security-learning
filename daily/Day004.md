# Day004：网络与协议基础 - TCP/UDP 与会话

- 日期：2025-12-28
- 周次：第 1 周

## 学习目标

- 掌握 TCP 三次握手与四次挥手
- 理解 UDP 的无连接特性与适用场景

## 学习内容

### 1️⃣ TCP 协议概述

**TCP（Transmission Control Protocol，传输控制协议）**

**核心特点：**

- ✅ **面向连接**：通信前必须建立连接
- ✅ **可靠传输**：确保数据正确、完整、按序到达
- ✅ **流量控制**：防止发送方发送过快
- ✅ **拥塞控制**：根据网络状况调整发送速率
- ✅ **全双工通信**：双向同时传输数据

**TCP 报文段结构：**

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          源端口 (16位)         |        目标端口 (16位)        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      序列号 (32位)                            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    确认号 (32位)                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|首部长|保留|U|A|P|R|S|F|                                       |
|度(4位)|(6位)|R|C|S|S|Y|I|         窗口大小 (16位)             |
|      |     |G|K|H|T|N|N|                                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          校验和 (16位)         |       紧急指针 (16位)         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       选项（可变长度）                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          数据                                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

**重要字段说明：**

| 字段             | 说明                           | 示例             |
| ---------------- | ------------------------------ | ---------------- |
| **源端口**       | 发送方端口号                   | 54321            |
| **目标端口**     | 接收方端口号                   | 80 (HTTP)        |
| **序列号 (Seq)** | 本次发送数据的第一个字节的序号 | 1000             |
| **确认号 (Ack)** | 期望接收的下一个字节的序号     | 2000             |
| **控制位**       | 6 个标志位，控制 TCP 连接状态  | SYN, ACK, FIN 等 |
| **窗口大小**     | 接收窗口大小，用于流量控制     | 65535 字节       |

**TCP 控制标志位（Flags）：**

| 标志位  | 全称           | 作用         | 值为 1 时的含义          |
| ------- | -------------- | ------------ | ------------------------ |
| **URG** | Urgent         | 紧急指针有效 | 紧急数据                 |
| **ACK** | Acknowledgment | 确认号有效   | 确认接收                 |
| **PSH** | Push           | 立即推送数据 | 不缓冲，立即传递给应用层 |
| **RST** | Reset          | 重置连接     | 异常关闭连接             |
| **SYN** | Synchronize    | 同步序列号   | 建立连接                 |
| **FIN** | Finish         | 结束发送     | 关闭连接                 |

---

### 2️⃣ TCP 三次握手（建立连接）

**目的：** 建立可靠的双向通信通道

**为什么需要三次握手？**

1. 确认双方都具备发送和接收能力
2. 协商初始序列号（ISN，Initial Sequence Number）
3. 协商 TCP 参数（窗口大小、MSS 等）

**三次握手流程图：**

```
客户端 (Client)                              服务器 (Server)
    │                                             │
    │         ① SYN (Seq=100)                     │
    │ ─────────────────────────────────────────> │
    │                                             │
    │    客户端状态: CLOSED → SYN_SENT            │  服务器状态: LISTEN
    │                                             │
    │                                             │
    │      ② SYN-ACK (Seq=200, Ack=101)           │
    │ <───────────────────────────────────────── │
    │                                             │
    │                                             │  服务器状态: LISTEN → SYN_RCVD
    │                                             │
    │         ③ ACK (Seq=101, Ack=201)            │
    │ ─────────────────────────────────────────> │
    │                                             │
    │    客户端状态: SYN_SENT → ESTABLISHED       │  服务器状态: SYN_RCVD → ESTABLISHED
    │                                             │
    │ ◀═══════════ 连接建立，开始传输数据 ═══════▶ │
    │                                             │
```

**详细步骤解析：**

**第一次握手（客户端 → 服务器）：**

```
┌────────────────────────────────────┐
│ TCP 报文内容：                     │
├────────────────────────────────────┤
│ SYN = 1                            │ ← 请求建立连接
│ ACK = 0                            │ ← 没有确认号
│ Seq = 100 (ISN_Client)             │ ← 客户端初始序列号
│ Ack = 0                            │ ← 无意义
├────────────────────────────────────┤
│ 含义："服务器，我想和你建立连接"  │
│       "我的初始序列号是 100"      │
└────────────────────────────────────┘

客户端状态变化：CLOSED → SYN_SENT
```

**第二次握手（服务器 → 客户端）：**

```
┌────────────────────────────────────┐
│ TCP 报文内容：                     │
├────────────────────────────────────┤
│ SYN = 1                            │ ← 服务器也请求建立连接
│ ACK = 1                            │ ← 确认收到客户端的 SYN
│ Seq = 200 (ISN_Server)             │ ← 服务器初始序列号
│ Ack = 101 (Client_Seq + 1)         │ ← 确认号：期望收到 101
├────────────────────────────────────┤
│ 含义："我收到你的请求了(ACK)"     │
│       "我也想和你建立连接(SYN)"   │
│       "我的初始序列号是 200"      │
│       "我期望你下次发送 Seq=101"  │
└────────────────────────────────────┘

服务器状态变化：LISTEN → SYN_RCVD
```

**第三次握手（客户端 → 服务器）：**

```
┌────────────────────────────────────┐
│ TCP 报文内容：                     │
├────────────────────────────────────┤
│ SYN = 0                            │ ← 连接建立阶段结束
│ ACK = 1                            │ ← 确认收到服务器的 SYN-ACK
│ Seq = 101                          │ ← 按服务器的期望发送
│ Ack = 201 (Server_Seq + 1)         │ ← 确认号：期望收到 201
├────────────────────────────────────┤
│ 含义："我收到你的确认了(ACK)"     │
│       "连接建立完成"              │
│       "可以开始传输数据了"        │
└────────────────────────────────────┘

客户端状态变化：SYN_SENT → ESTABLISHED
服务器状态变化：SYN_RCVD → ESTABLISHED

✅ 连接建立成功！双方进入 ESTABLISHED 状态
```

**为什么不能是两次握手？**

```
两次握手的问题：

场景：网络延迟导致的重复连接请求
┌─────────────────────────────────────────────────────┐
│ 1. 客户端发送 SYN (请求1)                            │
│    ↓ 网络延迟，包很久才到达                          │
│                                                      │
│ 2. 客户端超时，重新发送 SYN (请求2)                  │
│    ↓ 这个包很快到达                                  │
│                                                      │
│ 3. 服务器收到请求2，回复 SYN-ACK                     │
│    连接建立 ✅                                       │
│                                                      │
│ 4. 双方通信完成，连接关闭                            │
│                                                      │
│ 5. ⚠️ 延迟的请求1终于到达服务器                       │
│    如果是两次握手：服务器直接建立连接 ❌              │
│    服务器会一直等待客户端发数据                       │
│    但客户端认为连接已关闭，不会发送数据               │
│    → 造成服务器资源浪费                             │
│                                                      │
│ 三次握手的优势：                                     │
│    服务器发送 SYN-ACK 后，必须等待客户端确认         │
│    客户端不会对延迟的旧连接请求回复确认               │
│    → 服务器不会建立无效连接 ✅                       │
└─────────────────────────────────────────────────────┘
```

---

### 3️⃣ TCP 四次挥手（关闭连接）

**目的：** 安全、可靠地关闭双向通信

**为什么需要四次挥手？**

- TCP 是全双工通信（双向独立）
- 每个方向都需要单独关闭
- 确保双方数据都发送完毕

**四次挥手流程图：**

```
客户端 (Client)                              服务器 (Server)
    │                                             │
    │  ◀════════ 数据传输阶段 (ESTABLISHED) ════▶ │
    │                                             │
    │                                             │
    │         ① FIN (Seq=300)                     │
    │ ─────────────────────────────────────────> │
    │                                             │
    │   客户端状态: ESTABLISHED → FIN_WAIT_1       │
    │   含义："我没有数据要发送了"                │
    │                                             │
    │                                             │
    │         ② ACK (Ack=301)                     │
    │ <───────────────────────────────────────── │
    │                                             │
    │   客户端状态: FIN_WAIT_1 → FIN_WAIT_2        │  服务器状态: ESTABLISHED → CLOSE_WAIT
    │   含义："我知道你要关闭了"                  │  (服务器可能还有数据要发送)
    │                                             │
    │                                             │
    │         ③ FIN (Seq=400)                     │
    │ <───────────────────────────────────────── │
    │                                             │
    │                                             │  服务器状态: CLOSE_WAIT → LAST_ACK
    │                                             │  含义："我也没有数据了，准备关闭"
    │                                             │
    │         ④ ACK (Ack=401)                     │
    │ ─────────────────────────────────────────> │
    │                                             │
    │   客户端状态: FIN_WAIT_2 → TIME_WAIT         │  服务器状态: LAST_ACK → CLOSED ✅
    │                                             │
    │   (等待 2MSL 时间)                          │
    │         ↓                                   │
    │   客户端状态: TIME_WAIT → CLOSED ✅           │
    │                                             │
```

**详细步骤解析：**

**第一次挥手（客户端 → 服务器）：**

```
┌────────────────────────────────────┐
│ TCP 报文内容：                     │
├────────────────────────────────────┤
│ FIN = 1                            │ ← 请求关闭连接
│ ACK = 1                            │ ← 可能确认之前的数据
│ Seq = 300                          │ ← 当前序列号
│ Ack = 之前的值                     │
├────────────────────────────────────┤
│ 含义："我没有数据要发送了"        │
│       "但我还可以接收数据"        │
└────────────────────────────────────┘

客户端状态：ESTABLISHED → FIN_WAIT_1
```

**第二次挥手（服务器 → 客户端）：**

```
┌────────────────────────────────────┐
│ TCP 报文内容：                     │
├────────────────────────────────────┤
│ FIN = 0                            │
│ ACK = 1                            │ ← 确认收到客户端的 FIN
│ Seq = 400                          │
│ Ack = 301 (Client_Seq + 1)         │ ← 确认关闭请求
├────────────────────────────────────┤
│ 含义："我知道你要关闭了"          │
│       "但我可能还有数据要发送"    │
│       "请等我发送完"              │
└────────────────────────────────────┘

客户端状态：FIN_WAIT_1 → FIN_WAIT_2
服务器状态：ESTABLISHED → CLOSE_WAIT

⚠️ 此时连接处于半关闭状态：
    客户端 → 服务器：已关闭 ❌
    服务器 → 客户端：仍然可以发送数据 ✅
```

**第三次挥手（服务器 → 客户端）：**

```
┌────────────────────────────────────┐
│ TCP 报文内容：                     │
├────────────────────────────────────┤
│ FIN = 1                            │ ← 服务器也请求关闭
│ ACK = 1                            │
│ Seq = 500                          │
│ Ack = 301                          │
├────────────────────────────────────┤
│ 含义："我的数据也发送完了"        │
│       "我也要关闭连接了"          │
└────────────────────────────────────┘

服务器状态：CLOSE_WAIT → LAST_ACK
```

**第四次挥手（客户端 → 服务器）：**

```
┌────────────────────────────────────┐
│ TCP 报文内容：                     │
├────────────────────────────────────┤
│ FIN = 0                            │
│ ACK = 1                            │ ← 确认服务器的 FIN
│ Seq = 301                          │
│ Ack = 501 (Server_Seq + 1)         │
├────────────────────────────────────┤
│ 含义："我知道你也要关闭了"        │
│       "确认关闭"                  │
└────────────────────────────────────┘

服务器状态：LAST_ACK → CLOSED ✅ (立即关闭)
客户端状态：FIN_WAIT_2 → TIME_WAIT (等待 2MSL)
           TIME_WAIT → CLOSED ✅ (2MSL 后关闭)
```

**TIME_WAIT 状态（2MSL 等待）：**

```
MSL (Maximum Segment Lifetime): 报文段最大生存时间
通常 MSL = 30秒 或 2分钟（取决于系统）
2MSL = 60秒 或 4分钟

为什么需要 TIME_WAIT？

原因 1：确保最后的 ACK 能够到达服务器
┌─────────────────────────────────────┐
│ 客户端发送最后的 ACK                │
│    ↓                                │
│    如果 ACK 丢失                     │
│    ↓                                │
│ 服务器超时，重传 FIN                │
│    ↓                                │
│ 客户端在 TIME_WAIT 期间可以接收      │
│ 并重新发送 ACK                       │
└─────────────────────────────────────┘

原因 2：防止旧连接的数据干扰新连接
┌─────────────────────────────────────┐
│ 网络中可能还有延迟的旧数据包         │
│ 等待 2MSL 确保所有旧包都消失         │
│ 避免影响使用相同端口的新连接         │
└─────────────────────────────────────┘
```

---

### 4️⃣ TCP 状态转换图

**完整的 TCP 状态机：**

```
客户端状态转换                          服务器状态转换
    │                                      │
 CLOSED                                 CLOSED
    │                                      │
    │ (主动打开)                           │ (被动打开, listen())
    ↓                                      ↓
 SYN_SENT ──────① SYN─────────────────> LISTEN
    │                                      │
    │          ② SYN-ACK                   ↓
    │  <──────────────────────────── SYN_RCVD
    ↓                                      │
    │          ③ ACK                       │
ESTABLISHED ─────────────────────────> ESTABLISHED
    │                                      │
    │ (主动关闭)                           │
    │          ① FIN                       │
FIN_WAIT_1 ─────────────────────────> CLOSE_WAIT
    │                                      │ (被动关闭)
    │          ② ACK                       │
    ↓                                      │
FIN_WAIT_2                                 │
    │                                      │
    │          ③ FIN                       │
    │  <───────────────────────────── LAST_ACK
    ↓                                      │
    │          ④ ACK                       │
TIME_WAIT  ─────────────────────────>   CLOSED
    │
    │ (等待 2MSL)
    ↓
  CLOSED
```

**TCP 状态说明：**

| 状态            | 说明                        | 谁会进入   |
| --------------- | --------------------------- | ---------- |
| **CLOSED**      | 关闭状态，无连接            | 初始状态   |
| **LISTEN**      | 监听状态，等待连接请求      | 服务器     |
| **SYN_SENT**    | 已发送 SYN，等待服务器响应  | 客户端     |
| **SYN_RCVD**    | 已收到 SYN，等待最后的 ACK  | 服务器     |
| **ESTABLISHED** | 连接已建立，可以传输数据    | 双方       |
| **FIN_WAIT_1**  | 已发送 FIN，等待 ACK        | 主动关闭方 |
| **FIN_WAIT_2**  | 已收到 ACK，等待对方的 FIN  | 主动关闭方 |
| **CLOSE_WAIT**  | 已收到 FIN，等待应用层关闭  | 被动关闭方 |
| **LAST_ACK**    | 已发送 FIN，等待最后的 ACK  | 被动关闭方 |
| **TIME_WAIT**   | 等待 2MSL，确保连接安全关闭 | 主动关闭方 |

---

### 5️⃣ 五元组（会话标识）

**TCP 连接唯一标识：五元组**

```
五元组 = (源IP, 源端口, 目标IP, 目标端口, 协议)

示例：
┌─────────────────────────────────────┐
│ 源 IP:        192.168.31.36         │
│ 源端口:       54321                  │
│ 目标 IP:      172.217.160.142       │
│ 目标端口:     443 (HTTPS)            │
│ 协议:         TCP (6)                │
└─────────────────────────────────────┘

这个五元组唯一标识一个 TCP 连接
```

**为什么需要五元组？**

```
场景：浏览器同时访问多个网站

连接 1：访问百度
├─ 源 IP: 192.168.31.36
├─ 源端口: 54321
├─ 目标 IP: 220.181.38.148 (百度)
├─ 目标端口: 443
└─ 协议: TCP

连接 2：访问谷歌
├─ 源 IP: 192.168.31.36 (相同)
├─ 源端口: 54322 (不同) ← 通过不同端口区分
├─ 目标 IP: 172.217.160.142 (谷歌)
├─ 目标端口: 443 (相同)
└─ 协议: TCP

系统通过五元组区分这两个连接
收到数据包时，根据五元组判断属于哪个连接
```

**端口号范围：**

| 端口范围        | 类型          | 说明             | 示例                          |
| --------------- | ------------- | ---------------- | ----------------------------- |
| **0-1023**      | 知名端口      | 保留给系统服务   | 80(HTTP), 443(HTTPS), 22(SSH) |
| **1024-49151**  | 注册端口      | 应用程序注册使用 | 3306(MySQL), 8080(备用 HTTP)  |
| **49152-65535** | 动态/私有端口 | 客户端临时使用   | 浏览器发起连接时随机分配      |

---

### 6️⃣ UDP 协议对比

**UDP（User Datagram Protocol，用户数据报协议）**

**核心特点：**

- ⚠️ **无连接**：不需要建立连接，直接发送
- ⚠️ **不可靠**：不保证数据到达，不重传
- ⚠️ **无序**：不保证顺序
- ✅ **低开销**：首部只有 8 字节
- ✅ **快速**：没有握手、挥手过程
- ✅ **支持广播/多播**：一对多通信

**UDP 报文结构：**

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          源端口 (16位)         |        目标端口 (16位)        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         长度 (16位)            |         校验和 (16位)         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          数据                                 |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

只有 8 字节的首部！
```

**TCP vs UDP 对比：**

| 对比项        | TCP                  | UDP                     |
| ------------- | -------------------- | ----------------------- |
| **连接**      | 面向连接（握手）     | 无连接                  |
| **可靠性**    | 可靠（确认、重传）   | 不可靠                  |
| **顺序**      | 保证顺序             | 不保证                  |
| **速度**      | 较慢（有开销）       | 快速                    |
| **首部大小**  | 20-60 字节           | 8 字节                  |
| **流量控制**  | 有（窗口机制）       | 无                      |
| **拥塞控制**  | 有                   | 无                      |
| **广播/多播** | 不支持               | 支持                    |
| **适用场景**  | 文件传输、网页、邮件 | 视频通话、在线游戏、DNS |

**UDP 适用场景：**

```
✅ 实时音视频通话（如 Zoom、微信视频）
   原因：丢失少量数据包不影响体验，追求低延迟

✅ 在线游戏
   原因：需要快速响应，偶尔丢包可以容忍

✅ DNS 查询
   原因：查询数据量小，查询失败可以重试

✅ 直播流媒体
   原因：实时性要求高，丢失几帧不影响观看

✅ 物联网设备
   原因：设备资源有限，协议简单更合适
```

---

### 7️⃣ 常见问题与异常

**问题 1：SYN 洪泛攻击（SYN Flood）**

```
攻击原理：
攻击者 ──大量 SYN──> 服务器
         (伪造源IP)

服务器回复 SYN-ACK，等待最后的 ACK
但攻击者永远不发送 ACK
服务器维持大量半连接状态（SYN_RCVD）
→ 资源耗尽，无法处理正常连接

防护措施：
✅ SYN Cookie 技术
✅ 限制半连接数量
✅ 使用防火墙过滤
✅ 增加 SYN 队列大小
```

**问题 2：连接泄漏（Connection Leak）**

```
原因：应用程序没有正确关闭连接

后果：
├─ 客户端：大量 TIME_WAIT 状态
├─ 服务器：大量 CLOSE_WAIT 状态
└─ 端口耗尽，无法建立新连接

解决：
✅ 确保程序正确关闭 socket
✅ 使用连接池管理连接
✅ 设置合理的超时时间
```

**问题 3：大量 TIME_WAIT 状态**

```
原因：主动关闭方在 2MSL 期间保持 TIME_WAIT

影响：
├─ 占用大量端口（客户端端口范围有限）
└─ 频繁建立连接的场景（如爬虫）容易耗尽端口

优化：
✅ 使用长连接（HTTP Keep-Alive）
✅ 调整系统参数（减少 TIME_WAIT 时间）
✅ 使用 SO_REUSEADDR 选项
✅ 反向：让服务器主动关闭连接
```

## 实践任务（合法授权范围内）

### 🎯 任务 1: 使用 Wireshark 观察 TCP 三次握手与四次挥手

**准备工作：**

```powershell
# 确保 Wireshark 已安装
# 如果没有安装，执行：
winget install -e --id WiresharkFoundation.Wireshark
```

**步骤 1：启动 Wireshark 抓包**

1. 打开 Wireshark
2. 选择活动网络接口（Wi-Fi 或以太网）
3. 开始捕获

**步骤 2：设置显示过滤器**

```
tcp.flags.syn==1 or tcp.flags.fin==1
```

这个过滤器会显示所有带 SYN 或 FIN 标志的包（握手和挥手）

**步骤 3：访问网站触发 TCP 连接**

```powershell
# 使用 curl 访问网站（会自动关闭连接）
curl http://example.com

# 或者使用浏览器访问：
# http://neverssl.com (不使用 HTTPS，方便观察明文)
```

**步骤 4：停止抓包并分析**

**查找三次握手：**

```
在 Wireshark 中查找：
1. [SYN] 包 → 客户端发起
2. [SYN, ACK] 包 → 服务器响应
3. [ACK] 包 → 客户端确认

可以在 Info 列看到类似：
→ [SYN] Seq=0 Win=...
→ [SYN, ACK] Seq=0 Ack=1 Win=...
→ [ACK] Seq=1 Ack=1 Win=...
```

**查找四次挥手：**

```
在 Wireshark 中查找：
1. [FIN, ACK] 包 → 一方请求关闭
2. [ACK] 包 → 另一方确认
3. [FIN, ACK] 包 → 另一方也请求关闭
4. [ACK] 包 → 最终确认

可以在 Info 列看到类似：
→ [FIN, ACK] Seq=X Ack=Y
→ [ACK] Seq=Y Ack=X+1
→ [FIN, ACK] Seq=Y Ack=X+1
→ [ACK] Seq=X+1 Ack=Y+1
```

**步骤 5：详细分析 TCP 标志位**

点击任一 TCP 包，展开 "Transmission Control Protocol" 部分：

```
Transmission Control Protocol
├─ Source Port: 54321
├─ Destination Port: 80
├─ Sequence Number: 0 (relative)
├─ Acknowledgment Number: 0
├─ Header Length: 40 bytes
├─ Flags: 0x002 (SYN)  ← 重点查看
│   ├─ 000000.. = Reserved: Not set
│   ├─ ......0. = Nonce: Not set
│   ├─ .....0.. = Congestion Window Reduced: Not set
│   ├─ ....0... = ECN-Echo: Not set
│   ├─ ...0.... = Urgent: Not set
│   ├─ ..0..... = Acknowledgment: Not set
│   ├─ .0...... = Push: Not set
│   ├─ 0....... = Reset: Not set
│   ├─ 1....... = Syn: Set ✅
│   └─ .......0 = Fin: Not set
├─ Window: 65535
├─ Checksum: 0x1234
└─ Options: ...
```

---

### 🎯 任务 2: 查看本机 TCP 连接状态

**方法 1：使用 PowerShell（推荐）**

```powershell
# 查看所有 TCP 连接及状态
Get-NetTCPConnection | Format-Table LocalAddress, LocalPort, RemoteAddress, RemotePort, State -AutoSize

# 查看 ESTABLISHED 状态的连接
Get-NetTCPConnection -State Established | Format-Table

# 查看特定端口的连接（如 443 HTTPS）
Get-NetTCPConnection -RemotePort 443 | Format-Table

# 统计各状态的连接数
Get-NetTCPConnection | Group-Object -Property State | Sort-Object Count -Descending
```

**方法 2：使用 netstat 命令**

```powershell
# 查看所有 TCP 连接
netstat -an | findstr "TCP"

# 查看 ESTABLISHED 状态的连接
netstat -an | findstr "ESTABLISHED"

# 查看 TIME_WAIT 状态的连接（通常很多）
netstat -an | findstr "TIME_WAIT"

# 统计各状态的数量
netstat -an | findstr "TCP" | findstr /c:"ESTABLISHED" /c:"TIME_WAIT" /c:"CLOSE_WAIT"
```

**预期输出示例：**

```
协议   本地地址              外部地址              状态
TCP    192.168.31.36:54321   172.217.160.142:443  ESTABLISHED
TCP    192.168.31.36:54322   220.181.38.148:80    TIME_WAIT
TCP    192.168.31.36:54323   13.107.42.14:443     ESTABLISHED
TCP    0.0.0.0:135           0.0.0.0:0            LISTENING
```

---

### 🎯 任务 3: 构造 UDP 流量并对比 TCP

**DNS 查询（UDP 示例）**

```powershell
# 在 Wireshark 中设置过滤器
# dns

# 然后执行 DNS 查询
nslookup baidu.com

# 或者使用 Resolve-DnsName (PowerShell)
Resolve-DnsName baidu.com -Type A -Server 8.8.8.8
```

**在 Wireshark 中观察：**

**UDP 包特征：**

```
User Datagram Protocol
├─ Source Port: 54321
├─ Destination Port: 53 (DNS)
├─ Length: 45
└─ Checksum: 0x1234

特点：
✅ 没有握手过程
✅ 直接发送数据
✅ 没有确认机制
✅ 首部只有 8 字节
```

**与 TCP 对比：**

```
TCP (访问网站):
1. 三次握手（3 个包）
2. 数据传输（N 个包，带 ACK）
3. 四次挥手（4 个包）
总计：至少 7 个包

UDP (DNS 查询):
1. 直接发送查询（1 个包）
2. 收到响应（1 个包）
总计：2 个包

UDP 的优势：快速、低开销
UDP 的劣势：不保证可靠性
```

---

### 🎯 任务 4: 使用 telnet 手动模拟 TCP 连接

**连接到 HTTP 服务器：**

```powershell
# 连接到 example.com 的 80 端口
telnet example.com 80

# 然后手动输入 HTTP 请求（快速输入以下内容并按两次回车）：
GET / HTTP/1.1
Host: example.com

# 会看到服务器返回的 HTTP 响应
```

**同时在 Wireshark 中观察：**

- 可以看到三次握手
- 看到你输入的 HTTP 请求（明文）
- 看到服务器的响应
- 看到四次挥手（关闭连接）

---

### 🎯 任务 5: 分析真实场景的 TCP 会话

**步骤 1：在 Wireshark 中抓包**

```
# 过滤器设置为：
tcp.port == 443

# 然后用浏览器访问 https://www.baidu.com
```

**步骤 2：追踪 TCP 流**

在 Wireshark 中：

1. 右键点击任一属于该连接的包
2. 选择 "Follow" → "TCP Stream"
3. 会打开一个新窗口显示完整的会话内容

**步骤 3：提取五元组信息**

```
在包详情中查找：
┌─────────────────────────────────────┐
│ Internet Protocol Version 4         │
│ ├─ Source: 192.168.31.36            │ ← 源 IP
│ └─ Destination: 220.181.38.148      │ ← 目标 IP
│                                     │
│ Transmission Control Protocol       │
│ ├─ Source Port: 54321               │ ← 源端口
│ ├─ Destination Port: 443            │ ← 目标端口
│ └─ ...                              │
└─────────────────────────────────────┘

协议：TCP (传输层协议号 6)

五元组：
(192.168.31.36, 54321, 220.181.38.148, 443, TCP)
```

---

### 📊 实践任务总结检查清单

完成以下任务后，在对应项打勾：

- [ ] ✅ 使用 Wireshark 捕获 TCP 三次握手
- [ ] ✅ 在 Wireshark 中识别 SYN、SYN-ACK、ACK 包
- [ ] ✅ 使用 Wireshark 捕获 TCP 四次挥手
- [ ] ✅ 在 Wireshark 中识别 FIN、ACK 包
- [ ] ✅ 使用 `Get-NetTCPConnection` 查看本机连接状态
- [ ] ✅ 观察 TIME_WAIT、ESTABLISHED 等状态
- [ ] ✅ 使用 Wireshark 捕获 UDP 流量（DNS 查询）
- [ ] ✅ 对比 TCP 和 UDP 的包结构差异
- [ ] ✅ 从抓包中提取五元组信息
- [ ] ✅ 理解 TCP 标志位的含义

---

## 巩固练习（题与复盘）

### 📝 练习 1: 为什么有些应用更适合 UDP？举例说明

**题目：** 分析为什么某些应用选择 UDP 而不是 TCP？请举出 3 个例子并说明原因。

---

**答案：**

**示例 1：实时音视频通话（Zoom、微信视频、Skype）**

```
为什么用 UDP？
├─ 实时性要求：延迟必须低于 200ms 才有良好体验
├─ TCP 的问题：
│   ├─ 握手延迟：建立连接需要 1.5 RTT
│   ├─ 重传机制：丢包会触发重传，导致延迟增加
│   └─ 队头阻塞：一个包丢失会阻塞后续包
├─ UDP 的优势：
│   ├─ 无连接：立即发送，无建立延迟
│   ├─ 不重传：丢失的音视频帧直接跳过
│   └─ 低延迟：平均延迟更低
└─ 容忍度：丢失少量帧不影响通话质量（人耳/眼不敏感）

实际表现：
丢包 1-2%：几乎无感知 ✅
丢包 5%：偶尔卡顿，但可以接受
丢包 10%：明显卡顿，但仍能通话
延迟 200ms+ with TCP：无法正常对话 ❌
```

**示例 2：在线游戏（PUBG、王者荣耀、CS:GO）**

```
为什么用 UDP？
├─ 对实时性的极致要求：
│   └─ 射击游戏需要 <50ms 延迟才有良好体验
├─ TCP 的问题：
│   ├─ 重传导致延迟抖动
│   ├─ 拥塞控制降低发送速率
│   └─ 玩家位置、动作的旧数据没有价值
├─ UDP 的优势：
│   ├─ 最新状态优先：旧的位置更新直接丢弃
│   ├─ 稳定低延迟：不会因丢包触发重传
│   └─ 应用层控制：游戏自己实现可靠性（关键数据）
└─ 游戏设计：
    ├─ 关键数据（伤害、击杀）：应用层确认重传
    ├─ 非关键数据（位置更新）：丢了就丢了，用下一帧
    └─ 客户端预测 + 服务器校正机制

网络策略：
状态更新：UDP（每秒 20-60 次）
关键事件：UDP + 应用层重传确认
```

**示例 3：DNS 查询**

```
为什么用 UDP？
├─ 数据量小：
│   └─ DNS 查询通常 <512 字节，单个 UDP 包足够
├─ TCP 的浪费：
│   ├─ 三次握手：需要 3 个包
│   ├─ 查询请求：1 个包
│   ├─ 查询响应：1 个包
│   ├─ 四次挥手：4 个包
│   └─ 总计：9 个包
├─ UDP 的高效：
│   ├─ 查询请求：1 个包
│   ├─ 查询响应：1 个包
│   └─ 总计：2 个包
└─ 失败处理简单：
    └─ 如果无响应，客户端重新发送查询即可

性能对比：
TCP DNS 查询：需要 1.5 RTT (握手) + 1 RTT (查询) = 2.5 RTT
UDP DNS 查询：需要 1 RTT (查询)
效率提升：60%

注意：大响应（>512 字节）会降级到 TCP
```

**示例 4：流媒体直播（IPTV、网络直播）**

```
为什么用 UDP（或 RTP over UDP）？
├─ 实时性：直播延迟通常 2-5 秒
├─ TCP 的问题：
│   ├─ 丢包重传会增加延迟
│   ├─ 观众看到的画面会越来越延迟
│   └─ 缓冲区积压
├─ UDP 的优势：
│   ├─ 丢失几帧不影响观看体验
│   ├─ 保持稳定的延迟
│   └─ 支持多播（一对多）
└─ 容错机制：
    ├─ 视频编码：I 帧、P 帧冗余
    ├─ FEC（前向纠错）
    └─ 视频缓冲

多播优势：
服务器发送 1 份数据 → 网络设备复制 → 多个观众接收
TCP 无法实现多播
```

---

**总结：UDP 适用场景的共同特点**

| 特点                     | 说明                   | 示例应用           |
| ------------------------ | ---------------------- | ------------------ |
| **实时性要求高**         | 延迟比可靠性更重要     | 音视频通话、游戏   |
| **数据时效性**           | 旧数据价值低           | 游戏位置更新、直播 |
| **小数据量**             | 单包可以容纳           | DNS、DHCP、NTP     |
| **可容忍丢包**           | 丢失少量数据不影响整体 | 视频流、语音       |
| **需要广播/多播**        | 一对多通信             | IPTV、局域网发现   |
| **应用层自己实现可靠性** | 对关键数据选择性确认   | QUIC、游戏协议     |

---

### 📝 练习 2: 从抓包中提取一个 TCP 会话的五元组

**题目：** 假设在 Wireshark 中捕获了以下 TCP 包，请提取五元组信息。

**抓包信息：**

```
Frame 100: 74 bytes on wire
Ethernet II
├─ Destination: 38:3d:5b:0c:92:1c
├─ Source: c8:15:4e:a8:d3:fb
└─ Type: IPv4 (0x0800)

Internet Protocol Version 4
├─ Source: 192.168.31.36
├─ Destination: 220.181.38.148
├─ Protocol: TCP (6)
└─ ...

Transmission Control Protocol
├─ Source Port: 54321
├─ Destination Port: 443
├─ Sequence Number: 1000
├─ Acknowledgment Number: 2000
├─ Flags: 0x018 (PSH, ACK)
└─ ...
```

---

**答案：**

**提取的五元组：**

```
┌─────────────────────────────────────┐
│ TCP 连接五元组                      │
├─────────────────────────────────────┤
│ ① 源 IP 地址:    192.168.31.36      │ ← 发送方 IP
│ ② 源端口:        54321              │ ← 发送方端口（动态端口）
│ ③ 目标 IP 地址:  220.181.38.148     │ ← 接收方 IP（百度）
│ ④ 目标端口:      443                │ ← 接收方端口（HTTPS）
│ ⑤ 传输层协议:    TCP (6)            │ ← 协议类型
└─────────────────────────────────────┘

五元组表示：
(192.168.31.36:54321, 220.181.38.148:443, TCP)
```

**字段解释：**

| 字段         | 值             | 说明                                     |
| ------------ | -------------- | ---------------------------------------- |
| **源 IP**    | 192.168.31.36  | 本机 IP（私有地址）                      |
| **源端口**   | 54321          | 客户端随机分配的端口（49152-65535 范围） |
| **目标 IP**  | 220.181.38.148 | 百度服务器 IP                            |
| **目标端口** | 443            | HTTPS 服务（标准端口）                   |
| **协议**     | TCP (6)        | 传输层协议（IP 协议号 6）                |

**连接方向判断：**

```
客户端 → 服务器：
└─ 源端口 > 1024（动态端口）
   目标端口 = 443（标准服务端口）
   → 这是客户端发起的连接

服务器 → 客户端的回复包：
└─ 源端口 = 443
   目标端口 = 54321
   → 五元组相同（但源和目标交换）
```

**五元组的唯一性：**

```
场景：同时访问多个 HTTPS 网站

连接 1: (192.168.31.36:54321, 220.181.38.148:443, TCP) → 百度
连接 2: (192.168.31.36:54322, 172.217.160.142:443, TCP) → Google
连接 3: (192.168.31.36:54323, 220.181.38.148:443, TCP) → 百度新连接

虽然有相同的源 IP、目标 IP、目标端口
但源端口不同 → 五元组不同 → 不同的连接
```

**在 Wireshark 中快速查看五元组：**

```
方法 1：查看包详情
展开 IP 层 → 看源和目标 IP
展开 TCP 层 → 看源和目标端口

方法 2：使用统计功能
Statistics → Conversations → TCP
会列出所有 TCP 会话及其五元组信息

方法 3：使用过滤器
tcp.stream eq 0  # 查看第一个 TCP 流的所有包
```

---

### 📝 练习 3: 分析异常 TCP 连接状态

**题目：** 服务器上出现大量 CLOSE_WAIT 状态的连接，可能是什么原因？如何排查？

---

**答案：**

**CLOSE_WAIT 状态说明：**

```
TCP 四次挥手中的状态：
1. 客户端发送 FIN → 服务器收到
2. 服务器回复 ACK → 进入 CLOSE_WAIT 状态 ⚠️
3. 服务器应该发送 FIN → 完成关闭
4. 但如果应用程序没有关闭 socket → 一直停留在 CLOSE_WAIT

正常情况：CLOSE_WAIT 状态应该很快（几毫秒内）过渡到 LAST_ACK
异常情况：大量连接长时间停留在 CLOSE_WAIT → 应用程序问题
```

**可能的原因：**

**原因 1：应用程序未正确关闭 socket**

```python
# 错误的代码示例（Python）
def handle_client(conn):
    data = conn.recv(1024)
    process_data(data)
    # ❌ 忘记调用 conn.close()
    # 导致连接一直停留在 CLOSE_WAIT

# 正确的代码
def handle_client(conn):
    try:
        data = conn.recv(1024)
        process_data(data)
    finally:
        conn.close()  # ✅ 确保关闭
```

**原因 2：应用程序异常退出**

```
场景：
1. 客户端正常关闭连接（发送 FIN）
2. 服务器接收到 FIN，回复 ACK（进入 CLOSE_WAIT）
3. 应用程序处理数据时抛出异常
4. 异常未被捕获，线程/进程崩溃
5. socket 未被正确关闭 → CLOSE_WAIT 泄漏
```

**原因 3：应用程序逻辑阻塞**

```
场景：
1. 客户端关闭连接
2. 服务器进入 CLOSE_WAIT
3. 应用程序正在执行长时间操作（数据库查询、文件 I/O）
4. 应用程序尚未检测到连接关闭
5. 长时间停留在 CLOSE_WAIT

问题：缺少超时机制或定期检查连接状态
```

**排查步骤：**

**步骤 1：查看 CLOSE_WAIT 数量**

```powershell
# Windows
Get-NetTCPConnection -State CloseWait | Measure-Object

# Linux
netstat -an | grep CLOSE_WAIT | wc -l
```

**步骤 2：找出占用 CLOSE_WAIT 的进程**

```powershell
# Windows
Get-NetTCPConnection -State CloseWait |
    Select-Object LocalPort, RemoteAddress, RemotePort, OwningProcess |
    ForEach-Object {
        $_ | Add-Member -NotePropertyName ProcessName -NotePropertyValue (Get-Process -Id $_.OwningProcess).ProcessName -PassThru
    } | Format-Table

# Linux
netstat -anp | grep CLOSE_WAIT
```

**步骤 3：检查应用程序日志**

```
查找：
✅ 异常堆栈（未捕获的异常）
✅ 连接关闭日志（是否存在）
✅ 资源泄漏相关警告
```

**步骤 4：使用 strace/Process Monitor 跟踪**

```bash
# Linux: 跟踪系统调用
strace -p <PID> -e trace=close,shutdown

# Windows: 使用 Process Monitor
# 过滤 TCP Close 操作
```

**解决方案：**

```
✅ 代码层面：
   ├─ 使用 try-finally 确保 socket 关闭
   ├─ 使用 with 语句（Python）或 using（C#）
   ├─ 设置 socket 超时
   └─ 捕获并处理所有异常

✅ 架构层面：
   ├─ 使用连接池管理连接
   ├─ 实现心跳检测机制
   ├─ 设置空闲连接超时
   └─ 监控 CLOSE_WAIT 数量，告警

✅ 系统层面（临时措施）：
   ├─ 重启应用程序释放连接
   ├─ 调整 TCP 参数（不推荐，治标不治本）
   └─ 增加文件描述符限制
```

---

### 📝 练习 4: 理解 TCP 序列号

**题目：** 三次握手时，客户端发送 SYN (Seq=1000)，服务器回复 SYN-ACK (Seq=2000, Ack=1001)。客户端接下来应该发送什么？如果客户端要发送 100 字节数据，序列号如何变化？

---

**答案：**

**第三次握手（客户端发送）：**

```
TCP 报文：
├─ Flags: ACK = 1
├─ Seq = 1001  ← 按服务器期望的序号
├─ Ack = 2001  ← 服务器 Seq + 1
└─ Data: 无（或者携带应用层数据）

解释：
服务器的 Ack=1001 表示"期望收到 Seq=1001 的数据"
所以客户端下一个包的 Seq 必须是 1001
```

**发送 100 字节数据后：**

```
数据包 1：
├─ Seq = 1001
├─ Ack = 2001
├─ Data: 100 字节
└─ 实际占用序列号：1001-1100

服务器回复 ACK：
├─ Seq = 2001（服务器还没发数据）
├─ Ack = 1101  ← 1001 + 100 = 1101
└─ 含义："我收到了 1001-1100，期望下一个是 1101"

客户端下一个包：
├─ Seq = 1101  ← 必须从 1101 开始
└─ ...
```

**序列号计算规则：**

```
规则：
1. 初始序列号（ISN）：SYN 包中协商
2. 数据传输：Seq 增加 = 发送的字节数
3. ACK 确认：Ack = 对方 Seq + 对方数据字节数
4. SYN 和 FIN 各占用 1 个序列号（虽然不传输实际数据）

示例流程：
┌──────────────────────────────────────┐
│ 客户端                  服务器        │
├──────────────────────────────────────┤
│ SYN (Seq=1000)      →                │
│                     ← SYN-ACK        │
│                       (Seq=2000,     │
│                        Ack=1001)     │
│ ACK (Seq=1001,      →                │
│      Ack=2001)                       │
│ ─────── 连接建立 ────────             │
│ PSH,ACK (Seq=1001,  →                │
│          Ack=2001,                   │
│          Len=100)                    │
│                     ← ACK            │
│                       (Seq=2001,     │
│                        Ack=1101)     │
│ PSH,ACK (Seq=1101,  →                │
│          Ack=2001,                   │
│          Len=50)                     │
│                     ← ACK            │
│                       (Seq=2001,     │
│                        Ack=1151)     │
└──────────────────────────────────────┘

注意：
- SYN 占用 1 个序列号（1000 → 1001）
- 100 字节数据占用 100 个序列号（1001 → 1101）
- 50 字节数据占用 50 个序列号（1101 → 1151）
```

---

## 评估标准（达成判定）

- ✅ 能准确解释握手/挥手报文字段及顺序
- ✅ 能清晰区分 TCP 与 UDP 的差异

## 学习成果达成情况

### 📊 实践任务完成记录

#### **任务 1: 查看本机 TCP 连接状态** ✅

**执行命令：**

```powershell
Get-NetTCPConnection | Group-Object -Property State | Sort-Object Count -Descending
```

**输出结果：**

```
Count Name        说明
----- ----        -----
  290 Established  已建立的连接（正常数据传输）
  226 Bound        绑定到本地地址但未连接
  212 TimeWait     主动关闭方等待 2MSL
   61 Listen       监听状态（服务器等待连接）
   29 CloseWait    被动关闭方，等待应用程序关闭 ⚠️
    2 SynSent      已发送 SYN，等待响应
    1 FinWait1     已发送 FIN，等待 ACK
```

**关键发现：**

1. **Established (290 个)** - 正常

   - 主要是本地进程间通信（127.0.0.1）
   - 部分是与外网服务器的连接

2. **TimeWait (212 个)** - 正常

   - 主动关闭连接后的等待状态
   - 说明系统频繁建立和关闭连接
   - 这是正常现象，会在 2MSL 后自动清理

3. **CloseWait (29 个)** - 需要关注 ⚠️
   - 表示远程端已关闭连接
   - 但本地应用程序尚未关闭 socket
   - 如果数量持续增长，可能存在连接泄漏

**示例连接分析：**

```
五元组示例 1 (本地通信):
├─ 源 IP: 127.0.0.1
├─ 源端口: 64498
├─ 目标 IP: 127.0.0.1
├─ 目标端口: 64497
├─ 协议: TCP
└─ 状态: ESTABLISHED

五元组示例 2 (外网连接):
├─ 源 IP: 192.168.31.36 (本机)
├─ 源端口: 63283
├─ 目标 IP: 209.141.48.237 (外网服务器)
├─ 目标端口: 443 (HTTPS)
├─ 协议: TCP
└─ 状态: ESTABLISHED
```

---

#### **任务 2: 使用 Wireshark 观察 TCP 三次握手** (待完成)

**步骤：**

1. ✅ 打开 Wireshark，选择网络接口
2. ✅ 设置过滤器：`tcp.flags.syn==1 or tcp.flags.fin==1`
3. ✅ 访问网站：`curl http://example.com`
4. ✅ 停止抓包并分析

**预期观察到：**

```
三次握手：
1. [SYN] 客户端 → 服务器
   ├─ Seq = X (初始序列号)
   ├─ Ack = 0
   └─ Flags: SYN

2. [SYN, ACK] 服务器 → 客户端
   ├─ Seq = Y (服务器初始序列号)
   ├─ Ack = X + 1
   └─ Flags: SYN, ACK

3. [ACK] 客户端 → 服务器
   ├─ Seq = X + 1
   ├─ Ack = Y + 1
   └─ Flags: ACK

连接建立！双方进入 ESTABLISHED 状态
```

---

#### **任务 3: 使用 Wireshark 观察 TCP 四次挥手** (待完成)

**预期观察到：**

```
四次挥手：
1. [FIN, ACK] 客户端 → 服务器
   ├─ Seq = M
   ├─ Ack = N
   └─ Flags: FIN, ACK

2. [ACK] 服务器 → 客户端
   ├─ Seq = N
   ├─ Ack = M + 1
   └─ Flags: ACK

3. [FIN, ACK] 服务器 → 客户端
   ├─ Seq = N
   ├─ Ack = M + 1
   └─ Flags: FIN, ACK

4. [ACK] 客户端 → 服务器
   ├─ Seq = M + 1
   ├─ Ack = N + 1
   └─ Flags: ACK

连接关闭！
```

---

#### **任务 4: UDP 流量对比** (待完成)

**DNS 查询示例：**

```powershell
# 在 Wireshark 中设置过滤器：dns
nslookup baidu.com 8.8.8.8
```

**预期对比：**

```
TCP 连接（访问网站）：
├─ 三次握手：3 个包
├─ 数据传输：N 个包（每个都有 ACK）
├─ 四次挥手：4 个包
└─ 总计：至少 7+ 个包

UDP 查询（DNS）：
├─ 查询请求：1 个包
├─ 查询响应：1 个包
└─ 总计：2 个包

UDP 优势：
✅ 无建立连接开销
✅ 数据包少
✅ 延迟低
```

---

### 💡 核心知识点掌握

#### **1. TCP 三次握手** ✅

**为什么需要三次？**

```
目的：
✅ 确认双方收发能力
✅ 协商初始序列号（ISN）
✅ 协商 TCP 参数（窗口大小、MSS）
✅ 防止旧连接请求导致的资源浪费

两次握手的问题：
❌ 无法防止旧的重复连接请求
❌ 服务器无法确认客户端的接收能力

四次握手：
❌ 没有必要，三次已经足够
```

**流程记忆口诀：**

```
客户端："你好，我想连接" (SYN)
服务器："好的，我也想连接" (SYN-ACK)
客户端："收到，开始吧" (ACK)
```

---

#### **2. TCP 四次挥手** ✅

**为什么需要四次？**

```
原因：
✅ TCP 是全双工通信
✅ 每个方向需要独立关闭
✅ 确保双方数据都发送完毕

场景说明：
1. 客户端："我没数据要发了" (FIN)
2. 服务器："知道了" (ACK)
   [服务器可能还有数据要发]
3. 服务器："我也发完了" (FIN)
4. 客户端："知道了，再见" (ACK)
```

**为什么不能三次？**

```
如果合并步骤 2 和 3：
客户端发送 FIN 后，服务器可能还有数据要发送
如果立即回复 FIN，就无法发送剩余数据
所以需要先 ACK（我知道了），等发完数据再 FIN（我也关闭）
```

---

#### **3. TIME_WAIT 状态的意义** ✅

**为什么需要等待 2MSL？**

**原因 1：确保最后的 ACK 能到达**

```
场景：
1. 客户端发送最后的 ACK
2. 如果 ACK 丢失
3. 服务器超时重传 FIN
4. 客户端需要在 TIME_WAIT 状态接收并重发 ACK

如果没有 TIME_WAIT：
客户端已关闭 → 收到服务器的 FIN 重传 → 发送 RST
→ 服务器异常关闭
```

**原因 2：防止旧连接干扰**

```
场景：
1. 连接关闭后，网络中可能还有延迟的旧数据包
2. 如果立即使用相同的五元组建立新连接
3. 旧数据包可能被新连接接收
4. 导致数据混乱

2MSL 确保：
所有旧数据包都已消失（MSL = 30秒 或 2分钟）
```

---

#### **4. TCP vs UDP 的选择** ✅

**决策树：**

```
需要可靠传输？
├─ 是 → 需要保证数据完整性？
│   ├─ 是 → 使用 TCP ✅
│   │   └─ 场景：文件传输、网页、邮件
│   └─ 否 → 可以容忍少量丢失？
│       ├─ 是 → 使用 UDP ✅
│       │   └─ 场景：实时音视频、游戏
│       └─ 否 → 使用 TCP
└─ 否 → 实时性要求高？
    ├─ 是 → 使用 UDP ✅
    │   └─ 场景：DNS、NTP、DHCP
    └─ 否 → 根据其他因素决定
```

**快速判断表：**

| 需求             | 选择 | 典型应用         |
| ---------------- | ---- | ---------------- |
| 文件必须完整     | TCP  | HTTP 下载、FTP   |
| 网页必须完整显示 | TCP  | HTTPS、HTTP      |
| 邮件不能丢失     | TCP  | SMTP、POP3、IMAP |
| 视频通话（实时） | UDP  | Zoom、微信视频   |
| 游戏（低延迟）   | UDP  | 在线游戏         |
| 快速查询         | UDP  | DNS、NTP         |
| 直播（实时）     | UDP  | RTMP、HLS        |

---

#### **5. 五元组的作用** ✅

**唯一标识一个连接：**

```
五元组 = (源IP, 源端口, 目标IP, 目标端口, 协议)

系统如何区分多个连接：
场景：同时访问 10 个网站，都是 HTTPS (443)

连接 1: (192.168.31.36, 54321, IP1, 443, TCP)
连接 2: (192.168.31.36, 54322, IP2, 443, TCP)
连接 3: (192.168.31.36, 54323, IP3, 443, TCP)
...

虽然源IP、目标端口、协议都相同
但源端口不同 → 五元组不同 → 不同的连接
```

---

### 🔍 实践收获与反思

**关键理解：**

1. **TCP 的可靠性是有代价的**

   - 三次握手增加延迟（1.5 RTT）
   - 每个数据包都需要确认
   - 重传机制增加延迟
   - 适合文件传输、网页等不能出错的场景

2. **UDP 的"不可靠"是设计选择**

   - 不是缺陷，而是为了性能
   - 应用层可以选择性实现可靠性（如 QUIC）
   - 适合实时通信、快速查询等场景

3. **TIME_WAIT 不是问题，而是保护**

   - 确保连接安全关闭
   - 防止旧数据干扰新连接
   - 大量 TIME_WAIT 说明连接频繁（可以优化，但不一定是问题）

4. **CLOSE_WAIT 才需要关注**
   - 表示应用程序没有正确关闭连接
   - 可能导致连接泄漏
   - 需要检查代码逻辑

---

### 📖 与前几天学习的联系

**Day001: OSI 模型**

- ✅ TCP/UDP 工作在传输层（第 4 层）
- ✅ 负责端到端的数据传输

**Day002: MAC 与 ARP**

- ✅ 数据链路层使用 MAC 地址
- ✅ ARP 将 IP 映射到 MAC
- ✅ TCP 包最终封装在以太网帧中传输

**Day003: IP 与路由**

- ✅ 网络层的 IP 负责寻址和路由
- ✅ TCP 依赖 IP 层传输数据
- ✅ 五元组中的 IP 地址来自网络层

**协议栈协作：**

```
应用层：HTTP/HTTPS 请求
    ↓
传输层：TCP 三次握手 + 可靠传输 ← 本次学习
    ├─ 端口号识别应用
    ├─ 序列号保证顺序
    └─ 确认号保证可靠
    ↓
网络层：IP 路由选择 (Day003)
    ├─ 查路由表
    └─ 确定下一跳
    ↓
数据链路层：ARP + MAC 地址 (Day002)
    ├─ ARP 获取 MAC
    └─ 封装以太网帧
    ↓
物理层：电信号传输
```

---

### 🎓 学习成果评估

| 评估标准               | 达成情况 | 证据                                  |
| ---------------------- | -------- | ------------------------------------- |
| **能准确解释三次握手** | ✅ 达成  | 理解了 SYN、SYN-ACK、ACK 的作用和顺序 |
| **能准确解释四次挥手** | ✅ 达成  | 理解了全双工关闭和 TIME_WAIT 的必要性 |
| **能区分 TCP 与 UDP**  | ✅ 达成  | 掌握了两者的特点和适用场景            |
| **能提取五元组**       | ✅ 达成  | 能从抓包中识别连接的五元组            |
| **理解 TCP 状态机**    | ✅ 达成  | 能解释各种 TCP 状态的含义             |
| **能分析异常连接**     | ✅ 达成  | 能判断 CLOSE_WAIT 等异常状态的原因    |

---

**学习日期：** 2025-12-26  
**完成时间：** ⏰ 约 3 小时  
**学习效果：** ⭐⭐⭐⭐⭐ (5/5)

**下一步计划：**

- 📝 Day005: 深入 HTTP/HTTPS 协议
- 🔍 使用 Wireshark 实际抓包验证三次握手和四次挥手
- 💻 编写简单的 TCP 客户端和服务器程序（Python/C#）
